---2. gyak
A fordító csak a string konstans után rak /0-t
char s1[100] = "alma"; 100 helyet foglal, csak az első 5 helyen van konkrét elem
odáig van memóriában elem, ameddig az utolsó elem megvan határozva, ha előtte nincs meghatározva, akkor memória szemét van
nem mindegy, hogy számok stringként vannak kezelve, vagy binárisan, pl 4 bájtos szám binárisan 4 bájt mindig
de ha stringként, akkor lehet több és kevesebb is a memória

int pid = fork(); egész számot ad vissza, létrejövő process id-ját adja vissza

---4. gyak
direktori fájlbejegyzés és normál fájlbejegyzés
metainformációk, fájlnévhez kötödő bejegyzések a fájlnál, illetve a tartalom hol van.
Mi a fájl? bájtsorozat, metainformációk-kiegésztő, hol vannak a valós bájttartalmai a fájlnak
bájtsorozat- bináris fájl
szöveges mód is lehet kezelni fájlokat: karakter bájt megfeleltetés az ASCII kód táblán keresztül
Karakter kódjait nyomja ki fájlba- bináris fájltárolási módszer
1 karakter egy bájt
Számoknál lényeges a különbség-számok hexaként lekezelése, akkor annyi bájt amennyi karakter a szó, de ha binárisan irom, akkor több helyet foglal
Egy normál egész szám kettes komplemens tárolási elv szerint 4 bájtot foglal el
operátor: sizeof() pl szöveges 6: 212349, de binárisan csak 4
bináris fájl létrehozás strukturált kiiráskor jó
& karakterrel cimképzem a dolgokat, karaktereket, pointer, memóriacim kezdete és sizeof-fal nézhetjük meg, hogy mekkora a memóriacim területe
&Feri - hallgató struktura hibátlanul működjön, ha van a hallgató mezőben pointer akkor fog kiirni
int 4 bájt. char* is 4, az kerül a fájlba hogy adott pillanatban milyen memóriacim volt ott
char[100] - kikerül a fájlba rendesen a nevek
HF: struktúra szövegesen kiirni, meg binárisan, forkkal két gyerek

int i = 0;
for(i=1; i<?; i++){
	int pid = fork();
	if(pid==0){
	gyerek()
	}
}

IPC start
-szignálok!!
-csövek

man signal 0-31

--6. óra
mit jeleznek a jelzések? Hogy egy szám jelzéssel reprezentált szám megérkezett, windowsban ezeket esmeényeknek hivják
jelzések:
1. signal-kill, killel inditottuk el a szignált a megadott folyamatban. 7-es overview-t ad a szignálokról. 
real time szignál: 32-64, sigrt min és sigrt max
nincs plusz adatátviteli adattovábbTási lehetőség a jelek mellett. szignálok várnak, soros végülis ez
-c kapcsoló, csak compile, ne csak a default könyvtárakat lkinkelje be hanem az rt könyvtárat is
jelzés mellé hozzáadott értéket is tudunk tenni, 
2. sigaction-sigqueu
union tipus: takarékos struktúra, közös mezőre teszi, fixpontos 2-es komplemeteres számábrázolás az egész számok világában, valós: lebegőpontos
szignálok használata: vagy jelzést küldök vagy egy egész számot

Csövek
--8.óra
ütemező : write után read szülő által, gyerek 2 számot kellene beolvasnia, de második számnál várakozik örökké, csőben 2. adatot várja, műveleti jel
write utáni read ne automatikusan induljon el, kettő között wait(), várom a gyerek tevékenyéségének végét, így lesz rá ideje, wait helyett akár sleep()
1 másodperc alatt az ütemező átadja a gyereknek a folyamatot, sleep(1) nem a legszebb megoldás
2 féle megoldás: nem egy cső, hanem 2, szülőtől gyerek irányba 1, és vica versa, nincs csőkorlát, amennyi az op rendszer erőforrásai adnak
egy cső használat, de az egy cső használatot egymással szinkronizáljuk, nem automatikusan olvasok, hanem akkor olvasok amikor kapok jelzést
másik a kill, jelzés érkezésekor fogom kiolvasni, mint szülő az információt
szignálok küldése gépek között nem megoldott, lokális esetben jó, socket programozás
input fájlt vizsgálja, hogy tudunk-e olvasni, select és poll, időzítés
amelyik csatornán van adat abból utána lehet olvasni.
megjelenik egy dat és az tesztelhető
zh-ban véletlenszerű generált adat, randomizálni kell a randomot, legalább kettő cső
pause utasítás, jelzés, szülő azt csinálja, hogy vár 2 darab pose utasításra, parancsori argumentumtól, argv[1] int db-ben