<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 3.2//EN">
<!-- saved from url=(0070)http://www.cs.cf.ac.uk/Dave/C/node18.html#SECTION001800000000000000000 -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Input and Output (I/O):stdio.h</title>
<meta name="description" content="Input and Output (I/O):stdio.h">
<meta name="keywords" content="C">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">

<link rel="STYLESHEET" href="http://www.cs.cf.ac.uk/Dave/C/C.css">
</head>
<body>
<!--Table of Child-Links-->
<a name="CHILD_LINKS"><strong>Subsections</strong></a>
<ul>
<li><a name="tex2html1084" href="http://www.cs.cf.ac.uk/Dave/C/node18.html#SECTION001810000000000000000">
Reporting Errors</a>
<ul>
<li><a name="tex2html1085" href="http://www.cs.cf.ac.uk/Dave/C/node18.html#SECTION001811000000000000000">
<tt>perror()</tt></a>
</li><li><a name="tex2html1086" href="http://www.cs.cf.ac.uk/Dave/C/node18.html#SECTION001812000000000000000">
errno</a>
</li><li><a name="tex2html1087" href="http://www.cs.cf.ac.uk/Dave/C/node18.html#SECTION001813000000000000000">
<tt>exit()</tt></a>
</li></ul>
</li><li><a name="tex2html1088" href="http://www.cs.cf.ac.uk/Dave/C/node18.html#SECTION001820000000000000000">
Streams</a>
<ul>
<li><a name="tex2html1089" href="http://www.cs.cf.ac.uk/Dave/C/node18.html#SECTION001821000000000000000">
Predefined Streams</a>
<ul>
<li><a name="tex2html1090" href="http://www.cs.cf.ac.uk/Dave/C/node18.html#SECTION001821100000000000000">
Redirection</a>
</li></ul>
</li></ul>
</li><li><a name="tex2html1091" href="http://www.cs.cf.ac.uk/Dave/C/node18.html#SECTION001830000000000000000">
Basic I/O</a>
</li><li><a name="tex2html1092" href="http://www.cs.cf.ac.uk/Dave/C/node18.html#SECTION001840000000000000000">
Formatted I/O</a>
<ul>
<li><a name="tex2html1093" href="http://www.cs.cf.ac.uk/Dave/C/node18.html#SECTION001841000000000000000">
Printf</a>
</li></ul>
</li><li><a name="tex2html1094" href="http://www.cs.cf.ac.uk/Dave/C/node18.html#SECTION001850000000000000000">
scanf</a>
</li><li><a name="tex2html1095" href="http://www.cs.cf.ac.uk/Dave/C/node18.html#SECTION001860000000000000000">
Files</a>
<ul>
<li><a name="tex2html1096" href="http://www.cs.cf.ac.uk/Dave/C/node18.html#SECTION001861000000000000000">
Reading and writing files</a>
</li></ul>
</li><li><a name="tex2html1097" href="http://www.cs.cf.ac.uk/Dave/C/node18.html#SECTION001870000000000000000">
sprintf and sscanf</a>
<ul>
<li><a name="tex2html1098" href="http://www.cs.cf.ac.uk/Dave/C/node18.html#SECTION001871000000000000000">
Stream Status Enquiries</a>
</li></ul>
</li><li><a name="tex2html1099" href="http://www.cs.cf.ac.uk/Dave/C/node18.html#SECTION001880000000000000000">
Low Level I/O</a>
</li><li><a name="tex2html1100" href="http://www.cs.cf.ac.uk/Dave/C/node18.html#SECTION001890000000000000000">
Exercises</a>
</li></ul>
<!--End of Table of Child-Links-->
<hr>
<h1><a name="SECTION001800000000000000000">
Input and Output (I/O):<tt>stdio.h</tt></a>
</h1>
<a name="ch:io">&nbsp;</a>
This chapter will look at many forms of I/O. We have briefly mentioned some
forms before will look at these in much more detail here.
<br>
<p>
Your programs will need to include the standard I/O <em>header</em> file so do:
<br>
</p><p>&nbsp;&nbsp;&nbsp;<tt>#include &lt;stdio.h&gt;</tt>
</p><p></p><h1><a name="SECTION001810000000000000000">
Reporting Errors</a>
</h1>
<p>
Many times it is useful to report errors in a C program. The standard library
<tt>perror()</tt> is an easy to use and convenient function. It is used in
conjunction with <tt>errno</tt> and frequently on encountering an error you may
wish to terminate your program early. Whilst not strictly part of the <tt>
stdio.h</tt> library we introduce the concept of <tt>errno</tt> and the function <tt>
exit()</tt> here. We will meet these concepts in other parts of the Standard
Library also.
</p><p></p><h2><a name="SECTION001811000000000000000">
<tt>perror()</tt></a>
</h2>
<p>
The function <tt>perror()</tt>
 is prototyped by:
</p><p><code>void perror(const char *message);</code>
</p><p>
perror() produces a message (on  standard  error  output -- see
Section&nbsp;<a href="http://www.cs.cf.ac.uk/Dave/C/node18.html#sec:predstream">17.2.1</a>), describing the last error encountered, returned
to <tt>errno</tt> (see below)
     during a call to a system or library function.  The argument
     string <tt>message</tt>  is  printed first, then a colon and a blank, then
     the message and a newline.  If <tt>message</tt> is a NULL pointer
     or  points  to a null string, the colon is not printed.
</p><p></p><h2><a name="SECTION001812000000000000000">
errno</a>
</h2>
<p><tt>errno</tt> is a special <u>system</u> variable that is set if a system
call cannot perform its set task. It is defined in <tt>#include &lt;errno.h&gt;</tt>. 
<br>
</p><p>
To use <tt>errno</tt> in a C program it must be declared via:
<br>
</p><p>&nbsp;&nbsp;&nbsp;<tt>extern int errno;</tt>
<br>
</p><p>
It can be manually reset within a C program (although this is uncommon practice)
otherwise it simply retains its last value returned by a system call or library
function.
</p><p></p><h2><a name="SECTION001813000000000000000">
<tt>exit()</tt></a>
</h2>
<p>
The function <tt>exit()</tt> is prototyped in <code>#include &lt;stdlib&gt;</code> by:
</p><p><tt>void exit(int status)</tt>
</p><p>
Exit simply terminates the execution of a program
and returns the exit <tt>status</tt> value to the operating system. The <tt>
status</tt> value is used to indicate if the program has terminated properly:
</p><p></p><ul>
<li> it
exist with a <tt>EXIT_SUCCESS</tt> value on successful termination
</li><li> it
exist with a <tt>EXIT_FAILURE</tt> value on unsuccessful termination.
</li></ul>
<p>
On encountering an error you may frequently call an <tt>exit(EXIT_FAILURE)</tt>
to terminate an errant program.
</p><p></p><h1><a name="SECTION001820000000000000000">
Streams</a>
</h1>
<p><em>Streams</em> are a portable way of reading and writing data. They provide a
flexible and efficient means of I/O.
<br>
</p><p>
A Stream is a file <u>or</u> a physical device (<em>e.g.</em> printer or
monitor) which is manipulated with a <b>pointer</b> to the stream.
 <br>
</p><p>
There exists an internal C data structure, <tt>FILE</tt>, which represents all
streams and is defined in <tt>stdio.h</tt>. We simply need to refer to the <tt>
FILE</tt> structure in C programs when performing I/O with streams. 
 <br>
</p><p>
We just need to declare a variable or pointer of this type in our
programs. 
 <br>
</p><p>
We do not need to know any more specifics about this definition.
 <br>
</p><p>
We must <u>open</u> a stream before doing any I/O, 
 <br>
</p><p>
then <u>access</u>  it 
 <br>
</p><p>
and then <u>close</u> it.
  <br>
</p><p>
Stream I/O is <b>BUFFERED</b>: That is to say a fixed ``chunk'' is read from or
written to a file via some temporary storage area (the buffer). This is
illustrated in Fig.&nbsp;<a href="http://www.cs.cf.ac.uk/Dave/C/node18.html#fig:stream">17.1</a>. NOTE the file pointer actually points to
this buffer.
</p><p><a name="fig:stream">&nbsp;</a><img src="./Input and Output (I O) stdio.h_files/stream.gif">
</p><p>
<b>Fig.&nbsp;<a href="http://www.cs.cf.ac.uk/Dave/C/node18.html#fig:CDE"><img align="BOTTOM" border="1" alt="[*]" src="./Input and Output (I O) stdio.h_files/cross_ref_motif.gif"></a> Stream I/O Model</b>
This leads to efficient I/O but <b>beware</b>: data written to a buffer does not
appear in a file (or device) until the buffer is flushed or written out.
(<img width="12" height="32" align="MIDDLE" border="0" src="./Input and Output (I O) stdio.h_files/img3.gif" alt="$\backslash$">n does this). Any abnormal exit of code can cause problems.
</p><p></p><h2><a name="SECTION001821000000000000000">
Predefined Streams</a>
</h2>
<a name="sec:predstream">&nbsp;</a>
UNIX defines 3 predefined streams (in <tt>stdio.h</tt>):
<br>
<p>&nbsp;&nbsp;&nbsp;<tt>stdin,&nbsp;&nbsp;stdout,&nbsp;&nbsp;stderr</tt>
<br>
</p><p>
They all use text a the method of I/O.
<br>
</p><p><tt>stdin</tt> and <tt>stdout</tt> can be used with files, programs, I/O devices such
as keyboard, console, <em>etc.</em>. <tt>stderr</tt> <u>always</u> goes to the
console or screen.
<br>
</p><p>
The console is the default for <tt>stdout</tt> and <tt>stderr</tt>. The keyboard is
the default for <tt>stdin</tt>.
<br>
</p><p>
Predefined stream are automatically open.
 <br>
</p><p></p><h3><a name="SECTION001821100000000000000">
Redirection</a>
</h3>
<p>
This how we override the UNIX default predefined I/O defaults.
<br>
</p><p>
This is not part of C but operating system dependent. We will do redirection
from the command line. 
<br>
</p><p><b>&gt;</b> -- redirect <tt>stdout</tt> to a file.
<br>
</p><p>
So if we have a program, <tt>out</tt>, that usually prints to the screen then
<br>
</p><p>&nbsp;&nbsp;&nbsp;<tt>out &gt; file1</tt>
<br>
</p><p>
will send the output to a file, <tt>file1</tt>.
 <br>
</p><p><b>&lt;</b> -- redirect <tt>stdin</tt> from a file to a program.
<br>
</p><p>
So if we are expecting input from the keyboard for a program, <tt>in</tt> we can
read similar input from a file
<br>
</p><p>&nbsp;&nbsp;&nbsp;<tt>in &lt; file2</tt>.
<br>
</p><p><b>|</b> -- <em>pipe</em>: puts <tt>stdout</tt>  from one program to <tt>stdin</tt> of
another
<br>
</p><p>&nbsp;&nbsp;&nbsp;<tt>prog1 | prog2</tt>
<br>
</p><p><em>e.g.</em> Sent output (usually to console) of a program direct to printer:
<br>
</p><p>&nbsp;&nbsp;&nbsp;<tt>out | lpr</tt>
 <br>
</p><p></p><h1><a name="SECTION001830000000000000000">
Basic I/O</a>
</h1>
<p>
There are a couple of function that provide basic I/O facilities.
<br>
</p><p>
probably the most common are: <tt>getchar()</tt> and
<tt>putchar()</tt>. They are defined and used as follows:
</p><p></p><ul>
<li> <tt>int getchar(void)</tt> -- reads a char from <tt>stdin</tt>
</li><li> <tt>int putchar(char ch)</tt> -- writes a char to <tt>stdout</tt>, returns
character written.
</li></ul>
<p><tt>
</tt></p><pre><tt><tt>
&nbsp;&nbsp;&nbsp;int ch;
&nbsp;
		 ch = getchar();
		 (void) putchar((char) ch);
</tt></tt></pre><tt>
</tt>
<br>
<p>
Related Functions:
<br>
</p><p>&nbsp;&nbsp;&nbsp;<tt>int getc(FILE *stream), <br>
int putc(char ch,FILE *stream)
 <br>
</tt></p><p></p><h1><a name="SECTION001840000000000000000">
Formatted I/O</a>
</h1>
<p>
We have seen examples of how C uses formatted I/O already. Let's look at this
in more detail.
</p><p></p><h2><a name="SECTION001841000000000000000">
Printf</a>
</h2>
<a name="sec:printf">&nbsp;</a>
The function is defined as follows:
<br>
<p><tt>int printf(char *format, arg list ...)</tt> -- <br>
prints to <tt>stdout</tt>
the list of arguments according specified format string. Returns number of
characters printed.
<br>
</p><p>
The <b>format string</b> has 2 types of object:
</p><ul>
<li> <em>ordinary characters</em> -- these are copied to output.
</li><li> <em>conversion specifications</em> -- denoted by % and listed in
Table&nbsp;<a href="http://www.cs.cf.ac.uk/Dave/C/node18.html#tab:chars">17.1</a>.
</li></ul>
 <br>
<p>
<br>
</p><div align="CENTER"><a name="tab:chars">&nbsp;</a>
<a name="3064">&nbsp;</a>
<table cellpadding="3" border="1">
<caption><strong>Table:</strong>
Printf/scanf format characters</caption>
<tbody><tr valign="TOP"><td align="CENTER" nowrap="">Format Spec (%)</td>
<td align="CENTER" nowrap="">Type</td>
<td align="LEFT" nowrap="">Result</td>
</tr>
<tr valign="TOP"><td align="CENTER" nowrap="">c</td>
<td align="CENTER" nowrap="">char</td>
<td align="LEFT" nowrap="">single character</td>
</tr>
<tr valign="TOP"><td align="CENTER" nowrap="">i,d</td>
<td align="CENTER" nowrap="">int</td>
<td align="LEFT" nowrap="">decimal number</td>
</tr>
<tr valign="TOP"><td align="CENTER" nowrap="">o</td>
<td align="CENTER" nowrap="">int</td>
<td align="LEFT" nowrap="">octal number</td>
</tr>
<tr valign="TOP"><td align="CENTER" nowrap="">x,X</td>
<td align="CENTER" nowrap="">int</td>
<td align="LEFT" nowrap="">hexadecimal number</td>
</tr>
<tr valign="TOP"><td align="CENTER" nowrap="">&nbsp;</td>
<td align="CENTER" nowrap="">&nbsp;</td>
<td align="LEFT" nowrap="">lower/uppercase notation</td>
</tr>
<tr valign="TOP"><td align="CENTER" nowrap="">u</td>
<td align="CENTER" nowrap="">int</td>
<td align="LEFT" nowrap="">unsigned int</td>
</tr>
<tr valign="TOP"><td align="CENTER" nowrap="">s</td>
<td align="CENTER" nowrap="">char *</td>
<td align="LEFT" nowrap="">print string</td>
</tr>
<tr valign="TOP"><td align="CENTER" nowrap="">&nbsp;</td>
<td align="CENTER" nowrap="">&nbsp;</td>
<td align="LEFT" nowrap="">terminated by <img width="12" height="32" align="MIDDLE" border="0" src="./Input and Output (I O) stdio.h_files/img3.gif" alt="$\backslash$">0</td>
</tr>
<tr valign="TOP"><td align="CENTER" nowrap="">f</td>
<td align="CENTER" nowrap="">double/float</td>
<td align="LEFT" nowrap="">format -m.ddd...</td>
</tr>
<tr valign="TOP"><td align="CENTER" nowrap="">e,E</td>
<td align="CENTER" nowrap="">"</td>
<td align="LEFT" nowrap="">Scientific Format</td>
</tr>
<tr valign="TOP"><td align="CENTER" nowrap="">&nbsp;</td>
<td align="CENTER" nowrap="">&nbsp;</td>
<td align="LEFT" nowrap="">-1.23e002</td>
</tr>
<tr valign="TOP"><td align="CENTER" nowrap="">g,G</td>
<td align="CENTER" nowrap="">"</td>
<td align="LEFT" nowrap="">e or f whichever</td>
</tr>
<tr valign="TOP"><td align="CENTER" nowrap="">&nbsp;</td>
<td align="CENTER" nowrap="">&nbsp;</td>
<td align="LEFT" nowrap="">is most compact</td>
</tr>
<tr valign="TOP"><td align="CENTER" nowrap="">%</td>
<td align="CENTER" nowrap="">-</td>
<td align="LEFT" nowrap="">print % character</td>
</tr>
</tbody></table>
</div>
<br>
<p>
Between % and format char we can put:
</p><p></p><dl>
<dt><strong>- (minus sign)</strong>
</dt><dd>-- left justify.
</dd><dt><strong>integer number</strong>
</dt><dd>-- field width.
</dd><dt><strong>m.d</strong>
</dt><dd>-- m = field width, d = precision of number of digits after
decimal point <u>or</u> number of chars from a string.
</dd></dl>
<p>
<br>
</p><p>
So:
<br>
</p><p><tt>
</tt></p><pre><tt><tt>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("%-2.3f<img width="12" height="32" align="MIDDLE" border="0" src="./Input and Output (I O) stdio.h_files/img10.gif" alt="$\setminus$">n",17.23478);
</tt></tt></pre><tt>
</tt>
<br>
<p>
The output on the screen is:
<br>
</p><p><tt>
</tt></p><pre><tt><tt>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.235
</tt></tt></pre><tt><tt>
</tt>
<br>
<p>
and:
<br>
</p><p><tt>
</tt></p><pre><tt><tt>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("VAT=17.5%%<img width="12" height="32" align="MIDDLE" border="0" src="./Input and Output (I O) stdio.h_files/img10.gif" alt="$\setminus$">n");
</tt></tt></pre><tt><tt>
</tt>
<br>
<p>...outputs:
<br>
</p><p><tt>
</tt></p><pre><tt><tt>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VAT=17.5% 
</tt></tt></pre><tt><tt>
</tt>
</tt></tt><p><tt><tt></tt></tt></p><h1><a name="SECTION001850000000000000000">
scanf</a>
</h1>
<p>
This function is defined as follows:
<br>
</p><p><tt>&nbsp;&nbsp;&nbsp;int scanf(char *format, args....)</tt> -- reads from stdin and puts input
in address of variables specified in <tt>args</tt> list. Returns number of chars
read.
<br>
</p><p>
Format control string similar to <tt>printf</tt>
<br>
</p><p>
Note: The <u>ADDRESS</u> of variable or a pointer to one is required by <tt>
scanf</tt>.
<br>
</p><p>&nbsp;&nbsp;&nbsp;<tt>scanf(``%d'',&amp;i);</tt>
<br>
</p><p>
We can just give the name of an array or string to scanf since this corresponds
to the start address of the array/string.
<br>
</p><p><tt>
</tt></p><pre><tt><tt>
&nbsp;&nbsp;&nbsp;char string[80];
		 scanf(``%s'',string);
</tt></tt></pre><tt>
</tt>
<p></p><h1><a name="SECTION001860000000000000000">
Files</a>
</h1>
<p>
Files are the most common form of a stream.
<br>
</p><p>
The first thing we must do is <em>open</em> a file. The function <tt>fopen()</tt>
does this:
<br>
</p><p>&nbsp;&nbsp;&nbsp;<tt>FILE *fopen(char *name, char *mode)</tt>
<br>
</p><p><tt>fopen</tt> returns a pointer to a FILE. The <tt>name</tt> string is the name of
the file on disc that we wish to access. The <tt>mode</tt> string controls our
type of access. If a file cannot be accessed for any reason a <tt>NULL</tt>
pointer is returned.
<br>
</p><p></p><pre><tt>
Modes include: ``r'' -- read,
		 ``w'' -- write and
		 ``a'' -- append.
</tt></pre>
<p>
To open a file we must have a stream (file pointer) that <em>points</em> to a <tt>
FILE</tt> structure.
<br>
</p><p>
So to open a file, called <em>myfile.dat</em> for reading we would do:
<br>
</p><p><tt>
</tt></p><pre><tt><tt>
&nbsp;&nbsp;FILE *stream, *fopen();
		 /* declare a stream and prototype fopen */ 
&nbsp;
		 stream = fopen(``myfile.dat'',``r'');
&nbsp;
</tt><p><tt>
it is good practice to to check file is opened 
correctly:
&nbsp;
		 if ( (stream = fopen( ``myfile.dat'',
						``r'')) == NULL)
				 {&nbsp; printf(``Can't open %s<img width="12" height="32" align="MIDDLE" border="0" src="./Input and Output (I O) stdio.h_files/img3.gif" alt="$\backslash$">n'',
						 ``myfile.dat'');
				&nbsp; exit(1);
				 }
		 ......
</tt></p></tt></pre><tt>
</tt>
 <br>
<p></p><h2><a name="SECTION001861000000000000000">
Reading and writing files</a>
</h2>
<p>
The functions <tt>fprintf</tt> and <tt>fscanf</tt> a commonly used to access files.
 <br>
</p><p> <tt>
</tt></p><pre><tt><tt>
int fprintf(FILE *stream, char *format, args..)
		 int fscanf(FILE *stream, char *format, args..)
</tt></tt></pre><tt>
</tt>
<br>
<p>
These are similar to <tt>printf and <tt>scanf</tt> except that data is read from
the <em>stream</em> that must have been opened with <tt>fopen()</tt>.
<br>
</tt></p><p><tt>
The <tt>stream</tt> pointer is automatically incremented with <u>ALL</u> file
read/write functions. We <b>do not</b> have to worry about doing this.
<br>
</tt></p><p><tt><tt>
</tt></tt></p><pre><tt><tt><tt>
&nbsp;&nbsp;char *string[80]
		 FILE *stream, *fopen();
&nbsp;
		 if ( (stream = fopen(...)) != NULL)
				 fscanf(stream,``%s'', string);
</tt></tt></tt></pre><tt><tt>
</tt>
 <br>
<p>
Other functions for files:
<br>
</p><p><tt>int getc(FILE *stream), int fgetc(FILE *stream)
</tt></p><p><tt><tt>int putc(char ch, FILE *s), int fputc(char ch, FILE *s)</tt>
<br>
</tt></p><p><tt>
These are like <tt>getchar</tt>, <tt>putchar</tt>.
<br>
</tt></p><p><tt>
getc is defined as preprocessor MACRO in <tt>stdio.h</tt>. fgetc is a C library
function. Both achieve the same result!!
<br>
</tt></p><p><tt>&nbsp;&nbsp;&nbsp;<tt>fflush(FILE *stream)</tt> -- flushes a stream.
</tt></p><p><tt>&nbsp;&nbsp;&nbsp;<tt>fclose(FILE *stream)</tt> -- closes a stream.
<br>
</tt></p><p><tt>
We can access predefined streams with <tt>fprintf</tt> <em>etc.</em>
<br>
</tt></p><p><tt>&nbsp;&nbsp;&nbsp;<tt>fprintf(stderr,``Cannot Compute!!<img width="12" height="32" align="MIDDLE" border="0" src="./Input and Output (I O) stdio.h_files/img3.gif" alt="$\backslash$">n'');
</tt></tt></p><p><tt><tt>&nbsp;&nbsp;&nbsp; fscanf(stdin,``%s'',string);</tt>
<br>
</tt></p></tt><p><tt></tt></p><h1><a name="SECTION001870000000000000000">
sprintf and sscanf</a>
</h1>
<p>
These are like <tt>fprintf</tt> and <tt>fscanf</tt> except they read/write to a
string.
<br>
</p><p><tt>int sprintf(char *string, char *format, args..)
</tt></p><p><tt>
int sscanf(char *string, char *format, args..)</tt>
 <br>
</p><p>
For Example:
</p><p></p><pre><tt>
&nbsp;&nbsp;float full_tank = 47.0; /* litres */
		 float miles = 300;
		 char miles_per_litre[80];
&nbsp;
		 sprintf( miles_per_litre,``Miles per litre
				 = %2.3f'', miles/full_tank);
</tt></pre><h2><a name="SECTION001871000000000000000">
Stream Status Enquiries</a>
</h2>
<p>
There are a few useful stream enquiry functions, prototyped as follows:
</p><p> </p><pre> int feof(FILE *stream);
 int ferror(FILE *stream);
 void clearerr(FILE *stream);
 int fileno(FILE *stream);
</pre>
<p>
Their use is relatively simple:
</p><p> </p><dl>
<dt><strong><tt>feof()</tt></strong>
</dt><dd>-- returns  true if the stream is currently at the end of
the file. So to read a stream,<tt>fp</tt>, line by line you could do:
<pre>while ( !feof(fp) )
  fscanf(fp,"%s",line);
</pre>
<p></p></dd><dt><strong><tt>ferror()</tt></strong>
</dt><dd>-- reports on the error state of the stream and returns
true if an error has occurred.
<p></p></dd><dt><strong><tt>clearerr()</tt></strong>
</dt><dd>-- resets the error indication for a given stream.
<p></p></dd><dt><strong><tt>fileno()</tt></strong>
</dt><dd>-- returns the integer file descriptor associated with
     the named stream.
</dd></dl><h1><a name="SECTION001880000000000000000">
Low Level I/O</a>
</h1>
<p>
This form of I/O is <u>UNBUFFERED</u> -- each read/write request results
in accessing disk (or device) directly to fetch/put a specific number of <b>
bytes</b>.
<br>
</p><p>
There are no formatting facilities -- we are dealing with bytes of information.
<br>
</p><p>
This means we are now using binary (and <u>not</u> text) files.
<br>
</p><p>
Instead of file pointers we use <em>low level</em> <tt>file handle or file
descriptors</tt> which give a unique integer number to identify each file.
 <br>
</p><p>
To Open a file use:
<br>
</p><p>&nbsp;&nbsp;&nbsp;<tt>int open(char *filename, int flag, int perms)</tt> -- this returns a file
descriptor or -1 for a <b>fail</b>.
<br>
</p><p>
The <tt>flag</tt> controls file access and has the following predefined in <tt>
fcntl.h</tt>:
<br>
</p><p>&nbsp;&nbsp;&nbsp;<tt>O_APPEND, O_CREAT, O_EXCL, O_RDONLY, O_RDWR, O_WRONLY</tt> + others
see online <tt>man</tt> pages or reference manuals.
<br>
</p><p><tt>perms</tt> -- best set to 0 for most of our applications.
<br>
</p><p>
The function:
<br>
</p><p>&nbsp;&nbsp;&nbsp;<tt>creat(char *filename, int perms)</tt>
<br>
</p><p>
can also be used to create a file.
<br>
</p><p><tt>int close(int handle)</tt> -- close a file
 <br>
</p><p><tt>int read(int handle, char *buffer, <br>
unsigned length)
<br>
</tt></p><p><tt>
int write(int handle, char *buffer, unsigned length)</tt>
<br>
</p><p>
are used to read/write a specific number of bytes from/to a file (handle)
stored or to be put in the memory location specified by <tt>buffer</tt>.
<br>
</p><p>
The <tt>sizeof()</tt> function is commonly used to specify the <tt>length</tt>.
<br>
</p><p>
read and write return the number of bytes read/written or -1 if they fail.
 <br>
</p><p></p><pre><tt>
/* program to  read a list of floats from a binary file */
/* first byte of file is an integer saying how many  */
/* floats in file. Floats follow after it, File name got from */
/* command line */
&nbsp;
#include&lt;stdio.h&gt;
#include&lt;fcntl.h&gt;
&nbsp;
float bigbuff[1000];
&nbsp;
main(int argc, char **argv)
&nbsp;
{&nbsp; int fd;
		 int bytes_read;
		 int file_length;
&nbsp;
		 if ( (fd = open(argv[1],O_RDONLY)) = -1)
				 { /* error file not open */....
						 perror("Datafile");
						 exit(1);
				 }
		 if ( (bytes_read = read(fd,&amp;file_length,
						 sizeof(int))) == -1)
				 { /* error reading file */...
						 exit(1);
				 }
		 if ( file_length &gt; 999 )  {/* file too big */ ....}
		 if ( (bytes_read = read(fd,bigbuff,
						file_length*sizeof(float))) == -1)
				 { /* error reading open */...
						 exit(1);
				 }
}
</tt></pre>
<p></p><h1><a name="SECTION001890000000000000000">
Exercises</a>
</h1>
<p>
<b>Exercise 12573</b></p>
<p>
Write a program to copy one named file into another named file. The two file
names are given as the first two arguments to the program.
</p><p>
Copy the file a block (512 bytes) at a time.
</p><pre>Check: 	that the program has two arguments
      		  or print "Program need two arguments"
    		that the first name file is readable
      		  or print "Cannot open file .... for reading"
   		 that the second file is writable
     		   or print "Cannot open file .... for writing"
</pre>
<p></p>
<p>
</p><p>
<b>Exercise 12577</b></p>
<p>
Write a program last that prints the last <i>n</i> lines of a  text file, by <i>n</i> and
the file name should be specified form command line input. By default <i>n</i> should
be 5, but your program should allow an optional argument so that
</p><p></p><pre>			last -n file.txt
</pre>
<p>
prints out the last n lines, where n is any integer. Your program should make
the best use of available storage. 
</p>
<p>
</p><p></p><p>
<b>Exercise 12578</b></p>
<p>
Write a program to compare two files and print out the lines where they
differ. Hint: look up appropriate string and file handling library routines.
This should not be a very long program.
</p><p> </p>
<p>
<br></p><hr>
<address>
<i>Dave Marshall</i>
<br><i>1/5/1999</i>
</address>


</tt></body></html>