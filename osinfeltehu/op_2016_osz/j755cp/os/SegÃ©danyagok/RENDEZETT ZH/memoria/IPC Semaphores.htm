<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 3.2//EN">
<!-- saved from url=(0070)http://www.cs.cf.ac.uk/Dave/C/node26.html#SECTION002600000000000000000 -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>IPC:Semaphores</title>
<meta name="description" content="IPC:Semaphores">
<meta name="keywords" content="C">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">

<link rel="STYLESHEET" href="http://www.cs.cf.ac.uk/Dave/C/C.css">
</head>
<body>
<!--Table of Child-Links-->
<a name="CHILD_LINKS"><strong>Subsections</strong></a>
<ul>
<li><a name="tex2html1235" href="http://www.cs.cf.ac.uk/Dave/C/node26.html#SECTION002610000000000000000">
Initializing
a Semaphore Set</a>
</li><li><a name="tex2html1236" href="http://www.cs.cf.ac.uk/Dave/C/node26.html#SECTION002620000000000000000">
Controlling Semaphores</a>
</li><li><a name="tex2html1237" href="http://www.cs.cf.ac.uk/Dave/C/node26.html#SECTION002630000000000000000">
Semaphore Operations</a>
</li><li><a name="tex2html1238" href="http://www.cs.cf.ac.uk/Dave/C/node26.html#SECTION002640000000000000000">
POSIX Semaphores: &lt;semaphore.h&gt;</a>
</li><li><a name="tex2html1239" href="http://www.cs.cf.ac.uk/Dave/C/node26.html#SECTION002650000000000000000">
<tt>semaphore.c</tt>: Illustration of simple semaphore passing</a>
</li><li><a name="tex2html1240" href="http://www.cs.cf.ac.uk/Dave/C/node26.html#SECTION002660000000000000000">
Some further example semaphore programs</a>
<ul>
<li><a name="tex2html1241" href="http://www.cs.cf.ac.uk/Dave/C/node26.html#SECTION002661000000000000000">
<tt>semget.c</tt>: Illustrate the <tt>semget()</tt> function</a>
</li><li><a name="tex2html1242" href="http://www.cs.cf.ac.uk/Dave/C/node26.html#SECTION002662000000000000000">
<tt>semctl.c</tt>: Illustrate the <tt>semctl()</tt> function</a>
</li><li><a name="tex2html1243" href="http://www.cs.cf.ac.uk/Dave/C/node26.html#SECTION002663000000000000000">
<tt>semop()</tt> Sample Program to Illustrate <tt>semop()</tt></a>
</li></ul>
</li><li><a name="tex2html1244" href="http://www.cs.cf.ac.uk/Dave/C/node26.html#SECTION002670000000000000000">
Exercises</a>
</li></ul>
<!--End of Table of Child-Links-->
<hr>
<h1><a name="SECTION002600000000000000000">
IPC:Semaphores</a>
</h1>
<a name="ch:semaphores">&nbsp;</a>
Semaphores are a programming construct designed by
E. W. Dijkstra in the late 1960s. Dijkstra's model was the operation of
railroads: consider a stretch of railroad in which there is a single
track over which only one train at a time is allowed. Guarding this track
is a semaphore. A train must wait before entering the single track until
the semaphore is in a state that permits travel. When the train enters the
track, the semaphore changes state to prevent other trains from entering
the track. A train that is leaving this section of track must again
change the state of the semaphore to allow another train to enter. In the
computer version, a semaphore appears to be a simple integer. A
process (or a thread)  waits for permission to proceed by waiting for
the integer to become 0. The signal if it proceeds signals that this by
performing incrementing the integer by 1. 
When it is finished, the process changes the
semaphore's value by subtracting one from it.
<p>
Semaphores let processes query or alter status information. They are
often used to monitor and control the availability of system resources
such as shared memory segments.
</p><p>
Semaphores can be operated on as individual units or as elements in a
set. Because System V IPC semaphores can be in a large array, they are
extremely heavy weight. Much lighter weight semaphores are available in
the threads library (see <tt>man semaphore</tt> and also
Chapter&nbsp;<a href="http://www.cs.cf.ac.uk/Dave/C/node31.html#ch:thread_sem">30.3</a>) and POSIX semaphores (see below briefly).
Threads library semaphores must be used with mapped memory . A semaphore
set consists of a control structure and an array of individual
semaphores. A set of semaphores can contain up to 25 elements.
</p><p>
In a similar fashion to message queues, the semaphore set must be
initialized using <tt>semget()</tt>; the semaphore creator can change its
ownership or permissions using <tt>semctl()</tt>; and semaphore operations
are performed via the <tt>semop()</tt> function. These are now discussed
below:
</p><p></p><h1><a name="SECTION002610000000000000000">
Initializing
a Semaphore Set</a>
</h1>
<p>
The function <tt>semget()</tt> initializes or gains access to a semaphore.
It is prototyped by:
</p><p></p><pre>int semget(key_t key, int nsems, int semflg);
</pre>
<p>
When the call succeeds, it returns the semaphore ID (<tt>semid</tt>).
</p><p>
The
<tt>key</tt> argument is a access value associated with the semaphore ID.
</p><p>
The
<tt>nsems</tt> argument specifies the number of elements in a semaphore
array. The call fails when <tt>nsems</tt> is greater than the number of
elements in an existing array; when the correct count is not known,
supplying 0 for this argument ensures that it will succeed.
</p><p>
The <tt>
semflg</tt> argument specifies the initial access permissions and creation
control flags.
</p><p>
The following code
illustrates the semget() function.
</p><p></p><pre>#include &lt;sys/types.h&gt; 
#include &lt;sys/ipc.h&gt; 
#include &lt;sys/sem.h&gt; 

... 
key_t key; /* key to pass to semget() */ 
int semflg; /* semflg to pass tosemget() */ 
int nsems; /* nsems to pass to semget() */ 
int semid; /* return value from semget() */ 

... 

key = ... 
nsems = ...
semflg = ... ... 
if ((semid = semget(key, nsems, semflg)) == -1) {
		perror("semget: semget failed"); 
		exit(1); } 
else 
   ...
</pre>
<p></p><h1><a name="SECTION002620000000000000000">
Controlling Semaphores</a>
</h1>
<p> <tt>semctl()</tt> changes permissions and
other characteristics of a semaphore set. It is prototyped as follows:
</p><p></p><pre>int semctl(int semid, int semnum, int cmd, union semun arg);
</pre>
<p>
It must be called with a valid
semaphore ID, <tt>semid</tt>. The <tt>semnum</tt> value selects a semaphore
within an array by its index. The <tt>cmd</tt> argument is one of the
following control flags:
</p><dl>
<dt><strong><tt>GETVAL</tt></strong>
</dt><dd>-- Return the value of a single semaphore. 
</dd><dt><strong><tt>SETVAL</tt></strong>
</dt><dd>--  Set
the value of a single semaphore. In this case, arg is taken as arg.val, an
int. 
</dd><dt><strong><tt>GETPID</tt></strong>
</dt><dd>--  Return the <tt>PID</tt> of the process that
performed the last operation on the semaphore or array. 
</dd><dt><strong><tt>GETNCNT</tt></strong>
</dt><dd>--  Return the number of
processes waiting for the value of a semaphore to increase. 
</dd><dt><strong><tt>GETZCNT</tt></strong>
</dt><dd>-- 
Return the number of processes waiting for the value of a particular
semaphore to reach zero. 
</dd><dt><strong><tt>GETALL</tt></strong>
</dt><dd>--  Return the values for all semaphores in a
set. In this case, <tt>arg</tt> is taken as <tt>arg.array</tt>, a pointer to an
array of unsigned shorts (see below). 
</dd><dt><strong><tt>SETALL</tt></strong>
</dt><dd>--  Set values for all semaphores in a set. In this
case, <tt>arg</tt> is taken as <tt>arg.array</tt>, a pointer to an array of
unsigned shorts. 
</dd><dt><strong><tt>IPC_STAT</tt></strong>
</dt><dd>--  Return the status information from the control
structure for the semaphore set and place it in the data structure
pointed to by <tt>arg.buf</tt>, a pointer to a buffer of type <tt>
semid_ds</tt>.
<p></p></dd><dt><strong><tt>IPC_SET</tt></strong>
</dt><dd>--  Set the effective user
and group identification and permissions. In this case, <tt>arg</tt> is taken
as <tt>arg.buf</tt>. 
</dd><dt><strong><tt>IPC_RMID</tt></strong>
</dt><dd>--  Remove the specified semaphore set. 
</dd></dl>
<p>
A process must have
an effective user identification of owner, creator, or superuser to
perform an <tt>IPC_SET</tt> or <tt>IPC_RMID</tt> command. Read and write
permission is required as for the other control commands. The following
code illustrates <tt>semctl ()</tt>.
</p><p>
The  fourth  argument <tt>union semun arg</tt> is optional, depending upon
the operation requested.  If required  it  is of  type  <tt>union 
semun</tt>, which must be <em>explicitly</em> declared by the application
program as:
</p><p></p><pre>          union semun {
               int val;
               struct semid_ds *buf;
               ushort *array;
          } arg;
</pre>
<p></p><pre>#include &lt;sys/types.h&gt; 
#include &lt;sys/ipc.h&gt;
#include &lt;sys/sem.h&gt; 

union semun {
               int val;
               struct semid_ds *buf;
               ushort *array;
          } arg;

int i; 
int semnum = ....;
int cmd = GETALL; /* get value */



... 
i = semctl(semid, semnum, cmd, arg); 
if (i == -1) { 
		perror("semctl: semctl failed"); 
  exit(1); 
 }
else
...
</pre>
<p></p><h1><a name="SECTION002630000000000000000">
Semaphore Operations</a>
</h1>
<p><tt>semop()</tt> performs operations on a semaphore set. It is prototyped by:
</p><p></p><pre>int semop(int semid, struct sembuf *sops, size_t nsops);
</pre>
<p>
The <tt>semid</tt> argument
is the semaphore ID returned by a previous <tt>semget()</tt> call. 
The <tt>sops</tt>
argument is a pointer to an array of structures, each containing the
following information about a semaphore operation: 
</p><ul>
<li> The semaphore number
</li><li> The operation to be performed
</li><li> Control flags, if any.
</li></ul>
<p>
The <tt>sembuf</tt>
structure specifies a semaphore operation, as defined in
&lt;<tt>sys/sem.h</tt>&gt;.
</p><p></p><pre>struct sembuf {
        ushort_t        sem_num;        /* semaphore number */
        short           sem_op;         /* semaphore operation */
        short           sem_flg;        /* operation flags */
};
</pre>
<p>
The <tt>nsops</tt> argument specifies the length of the
array, the maximum size of which is determined by the <tt>SEMOPM</tt>
configuration option; this is the maximum number of operations allowed by
a single semop() call, and is set to 10 by default. The operation to be
performed is determined as follows: 
</p><ul>
<li> A positive integer increments the semaphore
value by that amount.
</li><li> A negative integer decrements the semaphore value
by that amount. An attempt to set a semaphore to a value less than zero
fails or blocks, depending on whether <tt>IPC_NOWAIT</tt> is in effect.
</li><li> A
value of zero means to wait for the semaphore value to reach zero.
</li></ul>
<p>
There
are two control flags that can be used with <tt>semop()</tt>:
</p><dl>
<dt><strong><tt>IPC_NOWAIT</tt></strong>
</dt><dd>-- Can
be set for any operations in the array. Makes the function return without
changing any semaphore value if any operation for which <tt>IPC_NOWAIT</tt>
is set cannot be performed. The function fails if it tries to decrement a
semaphore more than its current value, or tests a nonzero semaphore to be
equal to zero. 
</dd><dt><strong><tt>SEM_UNDO</tt></strong>
</dt><dd>--  Allows individual operations in the array to
be undone when the process exits. 
</dd></dl>
<p>
This function takes a
pointer, <tt>sops</tt>, to an array of semaphore operation structures. Each
structure in the array contains data about an operation to perform on a
semaphore. Any process with read permission can test whether a semaphore
has a zero value. To increment or
decrement a semaphore requires write permission. When an operation fails,
none of the semaphores is altered.
</p><p>
The process blocks (unless the <tt>IPC_NOWAIT</tt> flag is set), and
remains blocked until:
</p><p></p><ul>
<li> the semaphore operations can all finish, so the
call succeeds,
</li><li>
the process receives a signal, or
</li><li> the semaphore set is
removed.
<p></p></li></ul>
<p>
Only one process at a time can update a semaphore. Simultaneous
requests by different processes are performed in an arbitrary order. When
an array of operations is given by a <tt>semop()</tt> call, no updates are
done until all operations on the array can finish successfully.
</p><p>
If a process
with exclusive use of a semaphore terminates abnormally and fails to undo
the operation or free the semaphore, the semaphore stays locked in memory
in the state the process left it. To prevent this, the <tt>SEM_UNDO</tt>
control flag makes <tt>semop()</tt> allocate an undo structure for each
semaphore operation, which contains the operation that returns the
semaphore to its previous state. If the process dies, the system applies
the operations in the undo structures. This prevents an aborted process
from leaving a semaphore set in an inconsistent state. If processes share
access to a resource controlled by a semaphore, operations on the
semaphore should not be made with <tt>SEM_UNDO</tt> in effect. If the
process that currently has control of the resource terminates abnormally,
the resource is presumed to be inconsistent. Another process must be able
to recognize this to restore the resource to a consistent state. When
performing a semaphore operation with <tt>SEM_UNDO</tt> in effect, you must
also have it in effect for the call that will perform the reversing
operation. When the process runs normally, the reversing operation
updates the undo structure with a complementary value. This ensures that,
unless the process is aborted, the values applied to the undo structure
are cancel to zero. When the undo structure reaches zero, it is removed.
</p><p><b>NOTE:</b>Using <tt>SEM_UNDO</tt> inconsistently can lead to excessive
resource consumption because allocated undo structures might not be freed
until the system is rebooted.
</p><p>
The following code illustrates the <tt>semop()</tt>
function:
</p><pre>#include &lt;sys/types.h&gt; 
#include &lt;sys/ipc.h&gt; 
#include &lt;sys/sem.h&gt; 

... 
int i; 
int nsops; /* number of operations to do */ 
int semid; /* semid of semaphore set */ 
struct sembuf *sops; /* ptr to operations to perform */ 

... 

if ((semid = semop(semid, sops, nsops)) == -1) 
{ 
	perror("semop: semop failed"); 
 exit(1);
} 
else 
(void) fprintf(stderr, "semop: returned %d\n", i); 
...
</pre>
<p></p><h1><a name="SECTION002640000000000000000">
POSIX Semaphores: &lt;semaphore.h&gt;</a>
</h1>
<p>
POSIX semaphores are much lighter weight
than are System V semaphores. A POSIX semaphore structure defines a single
semaphore, not an array of up to twenty five semaphores. The POSIX
semaphore functions are:
</p><p><tt>sem_open()</tt> -- Connects to, and optionally
creates, a named semaphore
</p><p><tt>sem_init()</tt> -- Initializes a semaphore
structure (internal to the calling program, so not a named semaphore).
</p><p><tt>sem_close()</tt> -- Ends the connection to an open semaphore.
</p><p><tt>sem_unlink()</tt> --  Ends the connection to an open semaphore and
causes the semaphore to be removed when the last process closes it.
</p><p><tt>sem_destroy()</tt> -- Initializes a semaphore structure (internal to
the calling program, so not a named semaphore).
</p><p><tt>sem_getvalue()</tt> -- Copies the
value of the semaphore into the specified integer.
</p><p><tt>sem_wait(), sem_trywait()</tt> --  Blocks while the semaphore is held
by other processes or returns an error if the semaphore is held by another
process.
</p><p><tt>sem_post()</tt> -- Increments the count of the semaphore.
</p><p>
The basic operation of these functions is essence the same as described
above, except note there are more specialised functions, here. These are
not discussed further here and the reader is referred to the online <tt>
man</tt> pages for further details.
</p><p></p><h1><a name="SECTION002650000000000000000">
<tt>semaphore.c</tt>: Illustration of simple semaphore passing</a>
</h1>
<p></p><pre>/* semaphore.c --- simple illustration of dijkstra's semaphore analogy
 *
 *   We fork() a  child process so that we have two processes running:
 *   Each process communicates via a semaphore.
 *   The respective process can only do its work (not much here)
 *   When it notices that the semaphore track is free when it returns to 0
 *   Each process must modify the semaphore accordingly
 */
 
 #include &lt;stdio.h&gt;
 #include &lt;sys/types.h&gt;
 #include &lt;sys/ipc.h&gt;
 #include &lt;sys/sem.h&gt;
 
 union semun {
               int val;
               struct semid_ds *buf;
               ushort *array;
          };

main()
{ int i,j; 
  int pid;
  int semid; /* semid of semaphore set */
  key_t key = 1234; /* key to pass to semget() */
  int semflg = IPC_CREAT | 0666; /* semflg to pass to semget() */
  int nsems = 1; /* nsems to pass to semget() */
  int nsops; /* number of operations to do */
  struct sembuf *sops = (struct sembuf *) malloc(2*sizeof(struct sembuf)); 
  /* ptr to operations to perform */

  /* set up semaphore */
  
  (void) fprintf(stderr, "\nsemget: Setting up seamaphore: semget(%#lx, %\
%#o)\n",key, nsems, semflg);
   if ((semid = semget(key, nsems, semflg)) == -1) {
	perror("semget: semget failed");
	exit(1);
      } else 
	(void) fprintf(stderr, "semget: semget succeeded: semid =\
%d\n", semid);


  /* get child process */
  
   if ((pid = fork()) &lt; 0) {
        perror("fork");
        exit(1);
    }
    
if (pid == 0)
     { /* child */
       i = 0;
       
       
       while (i  &lt; 3) {/* allow for 3 semaphore sets */
       
       nsops = 2;
       
       /* wait for semaphore to reach zero */
       
       sops[0].sem_num = 0; /* We only use one track */
       sops[0].sem_op = 0; /* wait for semaphore flag to become zero */
       sops[0].sem_flg = SEM_UNDO; /* take off semaphore asynchronous  */
       
       
       sops[1].sem_num = 0;
       sops[1].sem_op = 1; /* increment semaphore -- take control of track */
       sops[1].sem_flg = SEM_UNDO | IPC_NOWAIT; /* take off semaphore */
       
       /* Recap the call to be made. */
       
       (void) fprintf(stderr,"\nsemop:Child  Calling semop(%d, &amp;sops, %d) with:", semid, nsops);
       for (j = 0; j &lt; nsops; j++)
	{
	  (void) fprintf(stderr, "\n\tsops[%d].sem_num = %d, ", j, sops[j].sem_num);
	  (void) fprintf(stderr, "sem_op = %d, ", sops[j].sem_op);
	  (void) fprintf(stderr, "sem_flg = %#o\n", sops[j].sem_flg);
	}
	
       /* Make the semop() call and report the results. */
	if ((j = semop(semid, sops, nsops)) == -1) {
		perror("semop: semop failed");
		} 
	   else 
             {
		(void) fprintf(stderr, "\tsemop: semop returned %d\n", j);
	
		(void) fprintf(stderr, "\n\nChild Process Taking Control of Track: %d/3 times\n", i+1);
		sleep(5); /* DO Nothing for 5 seconds */

      		 nsops = 1;
       
       		/* wait for semaphore to reach zero */
       		sops[0].sem_num = 0;
                sops[0].sem_op = -1; /* Give UP COntrol of track */
       		sops[0].sem_flg = SEM_UNDO | IPC_NOWAIT; /* take off semaphore, asynchronous  */
       
       	      	
       	      	if ((j = semop(semid, sops, nsops)) == -1) {
			perror("semop: semop failed");
			} 
		   else
		      (void) fprintf(stderr, "Child Process Giving up Control of Track: %d/3 times\n", i+1);
       	      	sleep(5); /* halt process to allow parent to catch semaphor change first */
       	      }
        ++i;
      }
       
     }
  else /* parent */
     {  /* pid hold id of child */
        
        i = 0;
       
       
       while (i  &lt; 3) { /* allow for 3 semaphore sets */
       
       nsops = 2;
       
       /* wait for semaphore to reach zero */
       sops[0].sem_num = 0;
       sops[0].sem_op = 0; /* wait for semaphore flag to become zero */
       sops[0].sem_flg = SEM_UNDO; /* take off semaphore asynchronous  */
       
       
       sops[1].sem_num = 0;
       sops[1].sem_op = 1; /* increment semaphore -- take control of track */
       sops[1].sem_flg = SEM_UNDO | IPC_NOWAIT; /* take off semaphore */
       
       /* Recap the call to be made. */
       
       (void) fprintf(stderr,"\nsemop:Parent Calling semop(%d, &amp;sops, %d) with:", semid, nsops);
       for (j = 0; j &lt; nsops; j++)
	{
	  (void) fprintf(stderr, "\n\tsops[%d].sem_num = %d, ", j, sops[j].sem_num);
	  (void) fprintf(stderr, "sem_op = %d, ", sops[j].sem_op);
	  (void) fprintf(stderr, "sem_flg = %#o\n", sops[j].sem_flg);
	}
	
       /* Make the semop() call and report the results. */
	if ((j = semop(semid, sops, nsops)) == -1) {
		perror("semop: semop failed");
		} 
	   else 
             {
		(void) fprintf(stderr, "semop: semop returned %d\n", j);
	
		(void) fprintf(stderr, "Parent Process Taking Control of Track: %d/3 times\n", i+1);
		sleep(5); /* Do nothing for 5 seconds */

      		 nsops = 1;
       
       		/* wait for semaphore to reach zero */
       		sops[0].sem_num = 0;
                sops[0].sem_op = -1; /* Give UP COntrol of track */
       		sops[0].sem_flg = SEM_UNDO | IPC_NOWAIT; /* take off semaphore, asynchronous  */
       
       		if ((j = semop(semid, sops, nsops)) == -1) {
			perror("semop: semop failed");
			} 
		   else
		      (void) fprintf(stderr, "Parent Process Giving up Control of Track: %d/3 times\n", i+1);
       	      	sleep(5); /* halt process to allow child to catch semaphor change first */
       	      }
        ++i;
        
      }
       
     }
}
</pre>
<p>
The key elements of this program are as follows:
</p><p></p><ul>
<li> After a semaphore is created with as simple key <tt>1234</tt>, two
prcesses are forked.
</li><li> Each process (parent and child) essentially performs the same
operations:
<ul>
<li> Each process accesses the same semaphore <em>track</em> (<tt>
sops[].sem_num = 0</tt>).
</li><li> Each process waits for the <em>track</em> to become free and then
attempts to take control of <em>track</em>
<p>
This is achieved by setting appropriate <tt>sops[].sem_op</tt> values in the
array.
</p></li><li> Once the process has control it sleeps for 5 seconds (in reality
some processing would take place in place of this simple illustration)
</li><li> The process then gives up control of the <em>track</em> <tt>
sops[1].sem_op = -1</tt>
</li><li> an additional sleep operation is then performed to ensure that the
other process has time to access the semaphore before a subsequent (same
process) semaphore read.
<p><b>Note</b>: There is no synchronisation here in this simple example an
we have no control over how the OS will schedule the processes.
</p></li></ul></li></ul><h1><a name="SECTION002660000000000000000">
Some further example semaphore programs</a>
</h1>
<p>
The following suite of programs can be used to investigate interactively
a variety of semaphore ideas (see exercises below).
</p><p>
The semaphore <b>must</b> be initialised with the <tt>semget.c</tt>
program. The effects of controlling the semaphore queue and sending and
receiving semaphore can be investigated with <tt>semctl.c</tt> and <tt>
semop.c</tt> respectively.
</p><p></p><h2><a name="SECTION002661000000000000000">
<tt>semget.c</tt>: Illustrate the <tt>semget()</tt> function</a>
</h2>
<p></p><pre>/*
 * semget.c: Illustrate the semget() function.
 *
 * This is a simple exerciser of the semget() function. It prompts
 * for the arguments, makes the call, and reports the results.
*/

#include   &lt;stdio.h&gt;
#include   &lt;sys/types.h&gt;
#include   &lt;sys/ipc.h&gt;
#include   &lt;sys/sem.h&gt;

extern void    exit();
extern void    perror();

main()
{
 key_t  key;   /* key to pass to semget() */
 int  semflg;   /* semflg to pass to semget() */
 int  nsems;   /* nsems to pass to semget() */
 int  semid;   /* return value from semget() */

 (void) fprintf(stderr,
  "All numeric input must follow C conventions:\n");
 (void) fprintf(stderr,
  "\t0x... is interpreted as hexadecimal,\n");
 (void) fprintf(stderr, "\t0... is interpreted as octal,\n");
 (void) fprintf(stderr, "\totherwise, decimal.\n");
 (void) fprintf(stderr, "IPC_PRIVATE == %#lx\n", IPC_PRIVATE);
 (void) fprintf(stderr, "Enter key: ");
 (void) scanf("%li", &amp;key);

 (void) fprintf(stderr, "Enter nsems value: ");
 (void) scanf("%i", &amp;nsems);
 (void) fprintf(stderr, "\nExpected flags for semflg are:\n");
 (void) fprintf(stderr, "\tIPC_EXCL = \t%#8.8o\n", IPC_EXCL);
 (void) fprintf(stderr, "\tIPC_CREAT = \t%#8.8o\n",
IPC_CREAT);
 (void) fprintf(stderr, "\towner read = \t%#8.8o\n", 0400);
 (void) fprintf(stderr, "\towner alter = \t%#8.8o\n", 0200);
 (void) fprintf(stderr, "\tgroup read = \t%#8.8o\n", 040);
 (void) fprintf(stderr, "\tgroup alter = \t%#8.8o\n", 020);
 (void) fprintf(stderr, "\tother read = \t%#8.8o\n", 04);
 (void) fprintf(stderr, "\tother alter = \t%#8.8o\n", 02);
 (void) fprintf(stderr, "Enter semflg value: ");
 (void) scanf("%i", &amp;semflg);
 (void) fprintf(stderr, "\nsemget: Calling semget(%#lx, %
     %#o)\n",key, nsems, semflg);
 if ((semid = semget(key, nsems, semflg)) == -1) {
  perror("semget: semget failed");
  exit(1);
 } else {
  (void) fprintf(stderr, "semget: semget succeeded: semid =
%d\n",
   semid);
  exit(0);
 }
}
</pre>
<p></p><h2><a name="SECTION002662000000000000000">
<tt>semctl.c</tt>: Illustrate the <tt>semctl()</tt> function</a>
</h2>
<p></p><pre>/*
 * semctl.c:   Illustrate the semctl() function.
 *
 * This is a simple exerciser of the semctl() function. It lets you
 * perform one control operation on one semaphore set. It gives up
 * immediately if any control operation fails, so be careful not
to
 * set permissions to preclude read permission; you won't be able
to
 * reset the permissions with this code if you do.
 */

#include    &lt;stdio.h&gt;
#include    &lt;sys/types.h&gt;
#include    &lt;sys/ipc.h&gt;
#include    &lt;sys/sem.h&gt;
#include    &lt;time.h&gt;

struct semid_ds semid_ds;

static void   do_semctl();
static void   do_stat();
extern char   *malloc();
extern void   exit();
extern void   perror();

char    warning_message[] = "If you remove read permission\
    for yourself, this program will fail frequently!";

main()
{
 union semun    arg;    /* union to pass to semctl() */
 int    cmd,    /* command to give to semctl() */
     i,    /* work area */
     semid,    /* semid to pass to semctl() */
     semnum;    /* semnum to pass to semctl() */

 (void) fprintf(stderr,
    "All numeric input must follow C conventions:\n");
 (void) fprintf(stderr,
    "\t0x... is interpreted as hexadecimal,\n");
 (void) fprintf(stderr, "\t0... is interpreted as octal,\n");
 (void) fprintf(stderr, "\totherwise, decimal.\n");
 (void) fprintf(stderr, "Enter semid value: ");
 (void) scanf("%i", &amp;semid);

 (void) fprintf(stderr, "Valid semctl cmd values are:\n");
 (void) fprintf(stderr, "\tGETALL = %d\n", GETALL);
 (void) fprintf(stderr, "\tGETNCNT = %d\n", GETNCNT);
 (void) fprintf(stderr, "\tGETPID = %d\n", GETPID);
 (void) fprintf(stderr, "\tGETVAL = %d\n", GETVAL);
 (void) fprintf(stderr, "\tGETZCNT = %d\n", GETZCNT);
 (void) fprintf(stderr, "\tIPC_RMID = %d\n", IPC_RMID);
 (void) fprintf(stderr, "\tIPC_SET = %d\n", IPC_SET);
 (void) fprintf(stderr, "\tIPC_STAT = %d\n", IPC_STAT);
 (void) fprintf(stderr, "\tSETALL = %d\n", SETALL);
 (void) fprintf(stderr, "\tSETVAL = %d\n", SETVAL);
 (void) fprintf(stderr, "\nEnter cmd: ");
 (void) scanf("%i", &amp;cmd);
 
 /* Do some setup operations needed by multiple commands. */
 switch (cmd) {
  case GETVAL:
  case SETVAL:
  case GETNCNT:
  case GETZCNT:
   /* Get the semaphore number for these commands. */
   (void) fprintf(stderr, "\nEnter semnum value: ");
   (void) scanf("%i", &amp;semnum);
   break;
  case GETALL:
  case SETALL:
   /* Allocate a buffer for the semaphore values. */
   (void) fprintf(stderr,
    "Get number of semaphores in the set.\n");
   arg.buf = &amp;semid_ds;
   do_semctl(semid, 0, IPC_STAT, arg);
   if (arg.array =
    (ushort *)malloc((unsigned)
     (semid_ds.sem_nsems * sizeof(ushort)))) {
    /* Break out if you got what you needed. */
    break;
   }
   (void) fprintf(stderr,
    "semctl: unable to allocate space for %d values\n",
    semid_ds.sem_nsems);
   exit(2);
 }

 /* Get the rest of the arguments needed for the specified
    command. */
 switch (cmd) {
  case SETVAL:
   /* Set value of one semaphore. */
   (void) fprintf(stderr, "\nEnter semaphore value: ");
   (void) scanf("%i", &amp;arg.val);
   do_semctl(semid, semnum, SETVAL, arg);
   /* Fall through to verify the result. */
   (void) fprintf(stderr,
    "Do semctl GETVAL command to verify results.\n");
  case GETVAL:
   /* Get value of one semaphore. */
   arg.val = 0;
   do_semctl(semid, semnum, GETVAL, arg);
   break;
  case GETPID:
   /* Get PID of last process to successfully complete a
      semctl(SETVAL), semctl(SETALL), or semop() on the
      semaphore. */
   arg.val = 0;
   do_semctl(semid, 0, GETPID, arg);
   break;
  case GETNCNT:
   /* Get number of processes waiting for semaphore value to
      increase. */
   arg.val = 0;
   do_semctl(semid, semnum, GETNCNT, arg);
   break;
  case GETZCNT:
   /* Get number of processes waiting for semaphore value to
      become zero. */
   arg.val = 0;
   do_semctl(semid, semnum, GETZCNT, arg);
   break;
  case SETALL:
   /* Set the values of all semaphores in the set. */
   (void) fprintf(stderr,
       "There are %d semaphores in the set.\n",
       semid_ds.sem_nsems);
   (void) fprintf(stderr, "Enter semaphore values:\n");
   for (i = 0; i &lt; semid_ds.sem_nsems; i++) {
    (void) fprintf(stderr, "Semaphore %d: ", i);
    (void) scanf("%hi", &amp;arg.array[i]);
   }
   do_semctl(semid, 0, SETALL, arg);
   /* Fall through to verify the results. */
   (void) fprintf(stderr,
    "Do semctl GETALL command to verify results.\n");
  case GETALL:
   /* Get and print the values of all semaphores in the
      set.*/
   do_semctl(semid, 0, GETALL, arg);
   (void) fprintf(stderr,
       "The values of the %d semaphores are:\n",
       semid_ds.sem_nsems);
   for (i = 0; i &lt; semid_ds.sem_nsems; i++)
    (void) fprintf(stderr, "%d ", arg.array[i]);
   (void) fprintf(stderr, "\n");
   break;
  case IPC_SET:
   /* Modify mode and/or ownership. */
   arg.buf = &amp;semid_ds;
   do_semctl(semid, 0, IPC_STAT, arg);
   (void) fprintf(stderr, "Status before IPC_SET:\n");
   do_stat();
   (void) fprintf(stderr, "Enter sem_perm.uid value: ");
   (void) scanf("%hi", &amp;semid_ds.sem_perm.uid);
   (void) fprintf(stderr, "Enter sem_perm.gid value: ");
   (void) scanf("%hi", &amp;semid_ds.sem_perm.gid);
   (void) fprintf(stderr, "%s\n", warning_message);
   (void) fprintf(stderr, "Enter sem_perm.mode value: ");
   (void) scanf("%hi", &amp;semid_ds.sem_perm.mode);
   do_semctl(semid, 0, IPC_SET, arg);
   /* Fall through to verify changes. */
   (void) fprintf(stderr, "Status after IPC_SET:\n");
  case IPC_STAT:
   /* Get and print current status. */
   arg.buf = &amp;semid_ds;
   do_semctl(semid, 0, IPC_STAT, arg);
   do_stat();
   break;
  case IPC_RMID:
   /* Remove the semaphore set. */
   arg.val = 0;
   do_semctl(semid, 0, IPC_RMID, arg);
   break;
  default:
   /* Pass unknown command to semctl. */
   arg.val = 0;
   do_semctl(semid, 0, cmd, arg);
   break;
 }
 exit(0);
}

/*
 * Print indication of arguments being passed to semctl(), call
 * semctl(), and report the results. If semctl() fails, do not
 * return; this example doesn't deal with errors, it just reports 
 * them.
 */
static void
do_semctl(semid, semnum, cmd, arg)
union semun  arg;
int  cmd,
  semid,
  semnum;
{
 register int      i;   /* work area */

 void) fprintf(stderr, "\nsemctl: Calling semctl(%d, %d, %d,
",
    semid, semnum, cmd);
 switch (cmd) {
  case GETALL:
   (void) fprintf(stderr, "arg.array = %#x)\n",
       arg.array);
   break;
  case IPC_STAT:
  case IPC_SET:
   (void) fprintf(stderr, "arg.buf = %#x)\n", arg.buf);
   break;
  case SETALL:
   (void) fprintf(stderr, "arg.array = [", arg.buf);
   for (i = 0;i &lt; semid_ds.sem_nsems;) {
    (void) fprintf(stderr, "%d", arg.array[i++]);
    if (i &lt; semid_ds.sem_nsems)
      (void) fprintf(stderr, ", ");
   }
   (void) fprintf(stderr, "])\n");
   break;
  case SETVAL:
  default:
   (void) fprintf(stderr, "arg.val = %d)\n", arg.val);
   break;
 }
 i = semctl(semid, semnum, cmd, arg);
 if (i == -1) {
  perror("semctl: semctl failed");
  exit(1);
 }
 (void) fprintf(stderr, "semctl: semctl returned %d\n", i);
 return;
}

/*
 * Display contents of commonly used pieces of the status
structure.
 */
static void
do_stat()
{
 (void) fprintf(stderr, "sem_perm.uid = %d\n",
       semid_ds.sem_perm.uid);
 (void) fprintf(stderr, "sem_perm.gid = %d\n",
       semid_ds.sem_perm.gid);
 (void) fprintf(stderr, "sem_perm.cuid = %d\n",
       semid_ds.sem_perm.cuid);
 (void) fprintf(stderr, "sem_perm.cgid = %d\n",
       semid_ds.sem_perm.cgid);
 (void) fprintf(stderr, "sem_perm.mode = %#o, ",
       semid_ds.sem_perm.mode);
 (void) fprintf(stderr, "access permissions = %#o\n",
       semid_ds.sem_perm.mode &amp; 0777);
 (void) fprintf(stderr, "sem_nsems = %d\n",
semid_ds.sem_nsems);
 (void) fprintf(stderr, "sem_otime = %s", semid_ds.sem_otime ?
      ctime(&amp;semid_ds.sem_otime) : "Not Set\n");
 (void) fprintf(stderr, "sem_ctime = %s",
       ctime(&amp;semid_ds.sem_ctime));
}
</pre>
<p></p><h2><a name="SECTION002663000000000000000">
<tt>semop()</tt> Sample Program to Illustrate <tt>semop()</tt></a>
</h2>
<p></p><pre>/*
 * semop.c: Illustrate the semop() function.
 *
 * This is a simple exerciser of the semop() function. It lets you
 * to set up arguments for semop() and make the call. It then
reports
 * the results repeatedly on one semaphore set. You must have read
 * permission on the semaphore set or this exerciser will fail.
(It
 * needs read permission to get the number of semaphores in the set
 * and to report the values before and after calls to semop().)
 */

#include    &lt;stdio.h&gt;
#include    &lt;sys/types.h&gt;
#include    &lt;sys/ipc.h&gt;
#include    &lt;sys/sem.h&gt;

static int      ask();
extern void     exit();
extern void     free();
extern char     *malloc();
extern void     perror();

static struct semid_ds  semid_ds;            /* status of semaphore set */

static char    error_mesg1[] = "semop: Can't allocate space for %d\
        semaphore values. Giving up.\n";
static char   error_mesg2[] = "semop: Can't allocate space for %d\
        sembuf structures. Giving up.\n";

main()
{
 register int    i;   /* work area */
 int    nsops;   /* number of operations to do */
 int    semid;   /* semid of semaphore set */
 struct sembuf    *sops;   /* ptr to operations to perform */

 (void) fprintf(stderr,
    "All numeric input must follow C conventions:\n");
 (void) fprintf(stderr,
    "\t0x... is interpreted as hexadecimal,\n");
 (void) fprintf(stderr, "\t0... is interpreted as octal,\n");
 (void) fprintf(stderr, "\totherwise, decimal.\n");
 /* Loop until the invoker doesn't want to do anymore. */
 while (nsops = ask(&amp;semid, &amp;sops)) {
  /* Initialize the array of operations to be performed.*/
  for (i = 0; i &lt; nsops; i++) {
   (void) fprintf(stderr,
     "\nEnter values for operation %d of %d.\n",
       i + 1, nsops);
   (void) fprintf(stderr,
     "sem_num(valid values are 0 &lt;= sem_num &lt; %d): ",
     semid_ds.sem_nsems);
   (void) scanf("%hi", &amp;sops[i].sem_num);
   (void) fprintf(stderr, "sem_op: ");
   (void) scanf("%hi", &amp;sops[i].sem_op);
   (void) fprintf(stderr,
     "Expected flags in sem_flg are:\n");
   (void) fprintf(stderr, "\tIPC_NOWAIT =\t%#6.6o\n",
     IPC_NOWAIT);
   (void) fprintf(stderr, "\tSEM_UNDO =\t%#6.6o\n",
     SEM_UNDO);
   (void) fprintf(stderr, "sem_flg: ");
   (void) scanf("%hi", &amp;sops[i].sem_flg);
  }

  /* Recap the call to be made. */
  (void) fprintf(stderr,
     "\nsemop: Calling semop(%d, &amp;sops, %d) with:",
     semid, nsops);
  for (i = 0; i &lt; nsops; i++)
  {
   (void) fprintf(stderr, "\nsops[%d].sem_num = %d, ", i,
      sops[i].sem_num);
   (void) fprintf(stderr, "sem_op = %d, ", sops[i].sem_op);
   (void) fprintf(stderr, "sem_flg = %#o\n",
      sops[i].sem_flg);
  }

  /* Make the semop() call and report the results. */
  if ((i = semop(semid, sops, nsops)) == -1) {
   perror("semop: semop failed");
  } else {
   (void) fprintf(stderr, "semop: semop returned %d\n", i);
  }
 }
}

/*
 * Ask if user wants to continue.
 *
 * On the first call:
 * Get the semid to be processed and supply it to the caller.
 * On each call:
 *  1. Print current semaphore values.
 *  2. Ask user how many operations are to be performed on the next
 *     call to semop. Allocate an array of sembuf structures
 *     sufficient for the job and set caller-supplied pointer to
that
 *     array. (The array is reused on subsequent calls if it is big
 *     enough. If it isn't, it is freed and a larger array is
 *     allocated.)
 */
static
ask(semidp, sopsp)
int   *semidp;  /* pointer to semid (used only the first time) */
struct sembuf   **sopsp;
{
 static union semun     arg;  /* argument to semctl */
 int     i;  /* work area */
 static int     nsops = 0;  /* size of currently allocated
           sembuf array */
 static int     semid = -1;   /* semid supplied by user */
 static struct sembuf    *sops;     /* pointer to allocated array */
 
 if (semid &lt; 0) {
  /* First call; get semid from user and the current state of
     the semaphore set. */
  (void) fprintf(stderr,
    "Enter semid of the semaphore set you want to use: ");
  (void) scanf("%i", &amp;semid);
  *semidp = semid;
  arg.buf = &amp;semid_ds;
  if (semctl(semid, 0, IPC_STAT, arg) == -1) {
   perror("semop: semctl(IPC_STAT) failed");
   /* Note that if semctl fails, semid_ds remains filled
      with zeros, so later test for number of semaphores will
      be zero. */
   (void) fprintf(stderr,
     "Before and after values are not printed.\n");
  } else {
   if ((arg.array = (ushort *)malloc(
    (unsigned)(sizeof(ushort) * semid_ds.sem_nsems)))
       == NULL) {
    (void) fprintf(stderr, error_mesg1,
       semid_ds.sem_nsems);
    exit(1);
   }
  }
 }
 /* Print current semaphore values. */
 if (semid_ds.sem_nsems) {
  (void) fprintf(stderr,
      "There are %d semaphores in the set.\n",
      semid_ds.sem_nsems);
  if (semctl(semid, 0, GETALL, arg) == -1) {
   perror("semop: semctl(GETALL) failed");
  } else {
   (void) fprintf(stderr, "Current semaphore values are:");
   for (i = 0; i &lt; semid_ds.sem_nsems;
    (void) fprintf(stderr, " %d", arg.array[i++]));
   (void) fprintf(stderr, "\n");
  }
 }
 /* Find out how many operations are going to be done in the
next
    call and allocate enough space to do it. */
 (void) fprintf(stderr,
     "How many semaphore operations do you want %s\n",
     "on the next call to semop()?");
 (void) fprintf(stderr, "Enter 0 or control-D to quit: ");
 i = 0;
 if (scanf("%i", &amp;i) == EOF || i == 0)
  exit(0);
 if (i &gt; nsops) {
  if (nsops)
   free((char *)sops);
  nsops = i;
  if ((sops = (struct sembuf *)malloc((unsigned)(nsops *
   sizeof(struct sembuf)))) == NULL) {
   (void) fprintf(stderr, error_mesg2, nsops);
   exit(2);
  }
 }
 *sopsp = sops;
 return (i);
}
</pre>
<p></p><h1><a name="SECTION002670000000000000000">
Exercises</a>
</h1>
<p>
<b>Exercise 12763</b></p>
<p>
Write  2 programs that will  communicate <b>both ways</b> (<em>i.e</em> each
process can read and write) when run concurrently via semaphores.</p>
<p></p><p>
<b>Exercise 12764</b></p>
<p>
Modify the <tt>semaphore.c</tt> program to handle synchronous semaphore
communication semaphores.</p>
<p></p><p>
<b>Exercise 12765</b></p>
<p>
Write 3 programs that communicate together via semaphores according to
the following specifications:
<tt>sem_server.c</tt> -- a program that can communicate independently
(on different semaphore tracks) with two clients programs.
<tt>sem_client1.c</tt> -- a program that talks to <tt>sem_server.c</tt>
on one track.
<tt>sem_client2.c</tt> -- a program that talks to <tt>sem_server.c</tt>
on another track to <tt>sem_client1.c</tt>.</p>
<p></p><p>
<b>Exercise 12766</b></p>
<p>
Compile the programs <tt>semget.c</tt>, <tt>semctl.c</tt> and <tt>semop.c</tt> and
then
</p><ul>
<li> investigate and understand fully the operations of the flags
(access, creation <em>etc.</em> permissions) you can set interactively in the
programs.
</li><li> Use the prgrams to:
<ul>
<li> Send and receive semaphores of 3 different semaphore <tt>track</tt>s.
</li><li> Inquire about the state of
the semaphore queue with <tt>semctl.c</tt>. Add/delete a few semaphores
(using <tt>semop.c</tt> and perform the inquiry once more.
</li><li> Use <tt>semctl.c</tt> to alter a semaphore on the queue.
</li><li> Use <tt>semctl.c</tt> to delete a semaphore from the queue.
</li></ul></li></ul><p></p>
<p>
<br></p><hr>
<address>
<i>Dave Marshall</i>
<br><i>1/5/1999</i>
</address>


</body></html>