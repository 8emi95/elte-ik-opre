2016.nov.10.
2 hét múlva nem lesz óra
3 hét múlva lesz (de lehet jövőhéten is jönni, uaz lesz)
4 hét múlva is lesz összevont
gyakorlati ZH napján nem lesz óra

szöveges infó az bináris infó
sleep: aktív alvás
pause: passzív alvás

gy3/csovezes.c (számolóközpont) lehetséges megoldásai:
	1. sleep használata 1 csővel (nem elegáns)
	2. több cső használata
	3. 1 cső használatával, szignálok küldésével

sel_cso uaz mint a poll_cso, csak a poll_cso-t egyszerűbb használni (későbbi POSIX szabvány)
	valamilyen szinkronizációt néhanapján csinálni kell

ha Viktóriával akarok csövezni, akkor Viki csövére akárhányan rákapcsolhatnak
Viki viszont ha mondjuk 5 csővel csövezik, ha írni akar, nincs problémája
	Mi a helyzet ha olvasni akar? Az ő read() parancsa addig vár, amíg a csőbe nem tesznek neki valami infót. Eddig a többi csőből sem tud olvasni, így a másik fél aki viszont nagyon akar csövezni mérges lesz Vikire, hogy már 3 órája nem olvasta el a csőben küldött üzenetet.
	sel_cso, poll_cso erre megoldás:
		POLLIN esemény: tudsz-e olvasni a csőből (azaz van benne infó)
		POLLOUT esemény: írásra elérhető-e a cső
		Viki felsorolja a használt csövek azonosítóit, aztán abból választ, amelyikben van valami. A poll_cso.c erre mutat mintakódot. Ha Vikinek nem írnak, azt mondja hogy "le vagytok fütyülve", és leklózolja a csöveket. Utána nézhetünk, ha írni akarunk neki.
		
printf: %c - char kiírása
poll_cso.c-ben: &cdata az char

rand(): generál valamit, ezelé egy srand() inicializálást kell tenni: srand(time());
srand(): kell kezdőbeállítást adni, legegyszerűbb a time() használata, mert az másodpercek számát adja vissza

pause(): egy szignál megérkezéséig passzív felfüggesztés
wait(): buta várakozás gyerek befejeződéséhez

gyak4.docx
ha ZH-ban üzenetsor a feladat, nem csövet használsz, ha cső, akkor nem üzenetsort
ha ZH-ban névtelen cső kell, nem nevesítettet használsz

1) feladatrészben a második gyereknek csak annyi a feladat, hogy ő is küldjön szignált hogy kész a munkára, más dolga ekkor még nincs, szóval befejeződik. Az első gyereknek fogadni is kell az adatokat és jelezni hogy sikerült.
	várakozás arra, hogy a gyerekek küldjék a jelzésüket: pause() egy szignál megérkezésére vár. Tehát 2 gyerek esetén 2 db pause() kell. Amint megérkezik egy szignál, egy pause() befejeződik. Két pause() esetén az első pause() az élelmesebb (gyorsabban szignált küldő) gyerek szignáljára fejeződik be.
	várakozás arra, hogy a gyerekek befejeződjenek: wait() egy gyerek befejezésére vár. Tehát 2 gyerek esetén 2 db wait() kell.
2) 20%-kal rossz az azonosító: generálok egy véletlen számot pl. 100-as intervallumba, ..., de a legegyszerűbb: az azonosítók 0-100-ig vannak, ha 20 alatt van az azonosító, akkor hibásnak tekintjük.
3) valahogy jelzem: 0 jelzi hogy szavazhat, 1 jelzi hogy nem szavazhat pl.
	kinek küldi a jelzést: kill(pid, signal);
		pid: process id, akinek küldi "signal"-t
4) a kocsmát mutex típusú szemaforral elég védeni (hogy egyszerre csak egy folyamat lehessen ott kint sört inni). Így ha egy folyamat megszomjazik és ki akar menni, megnézésre kerül hogy van-e valaki a sörözőbe. Amit be kell tenni tehát: mutex szemafor, elágazás, randomgenerátor (hogy ki mikor szomjazik meg).
