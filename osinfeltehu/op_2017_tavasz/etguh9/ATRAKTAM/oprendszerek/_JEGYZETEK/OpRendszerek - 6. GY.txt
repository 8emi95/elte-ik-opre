Május 12, 19 bemutatás (2. bead., az 1. nem kell), de hétközben is be lehet mutatni


5. gyakorlat anyagából maradt: osztott memória használat

A legegyszerûbb kommunikációk folyamatok között:
- kiírok fájlba, megnyitom más folyamatból -> PIPA
- jelzés küldés (fogadó csak a jelzés sorszámát kapja meg, erre reagál (megáll, ignorálja, blokkolja egy idõre, jelzéskezelõt futtat))
- csõvezetékek (lényeg: FIFO):
  * nevesített
  * nevesítettlen
- üzenetsor
  * posX
  * system5


Gond a csõvezetékkel: a várakozás is CPU igényes
Megoldás: poll, select utasítások használata (ha feljelentkezik rá egy folyamat, akkor az csak akkor kap vezérlést legkorábban, ha érkezik valami abba a ...szerkezetbe, amire az adott folyamat vár. Akár fájlra is rá lehet rakni ezt a konstrukciót, vagy socketre, vagy (system5ös??) csõvezetékre (bármilyen fájlleíróval rendelkezõ valamivel meg lehet csinálni))

Ha a csõvezeték minden író végét bezártuk, akkor
ha nem, akkor az olvasást használó folyamat érzékeli, hogy van még valaki aki írhat(na) a csõbe, ezért folyamatosan várakozik rá


system5: egyszerûbb használni, ezt néztük meg joban a múlt órán. Meg lehet címezni, hogy ki olvashatja az adott üzenetet ->  úgy mûködik, mintha párhuzamosan lenne egy csomó sor)
A posx-osban nincs ez a címzési lehetõség. viszont azért jobb, mert lehet olyat csinálni, hogy ha feljelentekztünk rá, akkor küldhet nekünk jelézést -> erõforrástakarékosabb. (viszont így visszaolvashatom a saját üzenetemet, nem lehet olyat csinálni mint a system5-ben)
De hogy lehetne a kettõt összekombinálni?


Ha létrehozunk egy gyerekfolyamatot, saját memóriaterülete lesz (akár más CPU-n is lehet a folyamat).
Akarjuk: legyen egy olyan osztott memóriarész, amit mindenki elér (ez a legegyszerûbb módja a kommunikációnak)




*** OSZTOTT MEMÓRIA (OM) HASZNÁLAT *** (osztmem.c)

ALAPOK:

kulcs=ftok(argv[0],1);   -   generál egy egyedi kulcsot egy létezõ fájlnév és egy egész szám (0/1..15) alapján

oszt_mem_id=shmget(kulcs,500,IPC_CREAT|S_IRUSR|S_IWUSR);   -   ezután meg kell adni (bájtonként), hogy mekkora memóriát szeretnénk használni, valamint beállítjuk a jogosultságokat (lsd. fájlkezelés)
most kész van az osztott memória (az oprsz létrehozott egy osztott memótiaterrületet)
de még nem tudjuk elérni (pedig szeretnénk)
le kell tehát kérni az oprenszertõl azt a címet, amin az alkalmazás majd hozzá tud férni ehhez az osztott memóriához
ez az s = shmat(oszt_mem_id,NULL,0);  fv el lehetséges
másik 2 paraméter: spec. körülmények között kell csak használni (valamelyik (saját) memóriaszegmenshez akarom kapcsolni a visszaadott fizikai címet (????))
Ha a fork elõtt van -> minden gyerekfolyamat felkapcsoloódik az om.-re (de lehetne külön is, hiszen bárhonnan fel lehet rá kapcsolódni)
a visszaadott cím void* (általános nmutató) típusú
az s viszont char* -os (úgy akarom használni az OM-t, mintha ott karakterek lennének)
bárminek használhatom az om-et (mi most szöveget akarunk kezelni)


OLVASÁS:

Fájlok esetén read, write, hosszúság megadás, stb... kellett, itt sokkal egyszerûbb dolgunk van: Úgy használhatjuk az OM-t, mintha egy saját területen dekalarált változó lenne (használható pl. az strcpy, vagy a printf("%s == a megadott cim (mert az egy cím) szövegként értelmezendõ") ha char*-ot csináltunk)

Ha olvasni akarunk (pl. a gyerekkel a szülõbõl), akkor fontos, hogy csak akkor tegyük ezt, ha már be van írva adat az OM-ba
->csúnya megoldás: sleep(1);
->szép: szignállal
(ha még nincs beírva semmi -> memóriaszemetet olvasunk, nulláig (??))


TÖRLÉS:

elengedjuk az om-et: shmdt(s);  -  ugye bárki bárhonnan használhatja (rácsatlakozhat) az OM-re, ezért nekünk kell azzal foglalkozni, hogy töröljük. de az oprendszer csak akkor engedi törölni, ha mindenki (aki rácsatlakozott (akár véletlenül) felteszi a kezét, hogy mehet a törlés (lecsatlakozik az OM-ról)

shmctl(oszt_mem_id,IPC_RMID,NULL);
(system5 os megvalosításoknál ...ctl fv eket  kell használni a törléshez)

ipcrm -el kell törölni a bentmaradt OM-kat (ipcs-vel lehet lekérni)
pl.: ipcrm -m 6881282, ahol a -m atzt jelenti, hogy ID alapján törlünk, a szám pedig az ID




*** SZEMAFOR HASZNÁLAT *** (szemafor.c)

Ebbõl is van 2 fajta, ZH-n nem mondják meg, hogy melyiket kell használni, nekünk kell eldönteni

Mire jó a szemafor? -> "Le lehet zárni a kritikus szakaszt"
Az egyik folyamat lezárja, így a többi nem férhet hozzá, egészen addig, amíg a lezáró fel nem engedi (a "kritikus szakaszt", vagyis az erõforrást)

Lehet természetesen olyan, hogy több kritikus szakasz van -> több szemafort kell használni

Csak szemaforcsalád létezik C-ben(?? vagy csak ebben a kornyezetben) (ez jó ha kell, de nehézkes ha csak egy szemafor kellett volna, mert akkor is kell a család beállításaival baszkodni)

2 állapotú rendszer: lezart(0), felnyitott (vmilyen pozitív szám (pl. 1, egyszerû esetben))


SZCS LÉTREHOZÁSA: semget(kulcs,1,IPC_CREAT|S_IRUSR|S_IWUSR ))   -   kulcs, vmio, jogosultságok
system5-re jellemzõ: Be kell állítqani a kezdõállapotokat (a csalad minden tagjának, kézzel): semctl(semid,0,SETVAL,szemafor_ertek)

törölni is a semctl(...)-el lehet, a beállítás és törlés azon múlik, hogy milyen a 3. paraméter (SETVAL vagy IPC_RMID)


a szemaforcsaládság miatt nehéz a szemafro kezelése
can egy struktúra ( sembuf ) és azzal kell csinálni

Mezok:
sem_num = 0;
   
sem_op  = op; // op=1 up, op=-1 down 
    
sem_flg = 0;   -   akkor használatos, ha ugy akarom használni a szemafor, hogy ha záérva van, akkor nem akarok várni, hanem továbba akarok menni (vagyis ránlézek a szemaforra és ha zta látom hogy zárt, akkor továbbmergyek.) ilyenjkor ez a flag nem nulla (de mi??)

Szemafor beállítása a megadott strukúra alapján: semop(semid,&muvelet,1)

szemafort csak akkor lehet letörölni, ha nyitott állapotban van


ha nem töröljük a szemafort, itt is az ipcs-s cuccot kell csinálni


POSX (SZABVÁNYOS) SZEMAFOR:

EGYSZERÛBB A HASZNÁLAT, MERT LEHET egy szemafort csinálni

posx-ban mindig egy fáljlnév alapján történik az azonosítás (most kell / a fájjlnév elejére??)
(char* sem_nev="/alma1";)
érdemes a saját neptunkódot használni ilyenkorfájlnévként, mert a posx-os cuccok egy központi könyvtárban jönnek létre és elbaszódhat a rendszer -> összekeveri a cuccokat

várakozás:
sem_wait(semid);   -   semid: szemafor azonosítója
ha bemehet, akkor bezárja maga után

-pthread kapcsolóval kell fordítani




ftok helyett:

speciális esetben ezt a kulcsot lehet helyettesíteni egy beégetett konstansértékkel (IPC_CREAT)
mire jó ez? -> Egy adott programon belüli OM-t/szemafort lehet létrehozni -> nem lehet rácsalakozni kívülrõl (ami egyébként lehetséges (ha tudjuk a fájlnevet meg a számot??))

Amúgy: Hogyan adom át egy folyamatnak a kulcsot -> egy fájlban tároljuk, ahonnan mindenki ki tudja olvasni (??)




Feladatok:
Két különálló program (nem szülõ-gyerek) kommunikációjának megírása. Hogyan tudja meg az egyik folyamat a másik pid számát?
Pl.: a második folyamat paraméterben kapja az elsõjét, ezutén egy szignállal (vagy egy nevesített (mert nevesítetlent nem tudok használni??) csõvezetéken kereszül) elküldjük az elsõnek a másodikét

egyéb(?) jó megoldás: exec hívás: új folyamatot indítunk ??

csõvezetékbe írás-olvasás szinkronizálásának megoldása:
két csõvezeték, jelzésküldés, szemafor