Folyamatok közti kommunikáció

A példakódokban szülõ-gyerek kommunikáció van, de lehetnének bármilyen folyamatok is

A fogadó fél csak annyit tud, hogy milyen típusú jelzés érkezett

32 normál (standard) jelzés van
Ezekkel mûködik az OPRSZ (pl. lenyomjuk a ctrl + c-t  ->  kap az éppen futó folyamat egy jelzést hogy álljon le)

Az OPRSZ egész szám formájában tárolja hogy milyen jelzés érkezett és hogy milyen feladatai vannak a jelzésekkel kapcsolatban (??)
De hogy a felhasználónak könnyebb legyen, vannak szöveges aliasok
Pl.:  sig kill  -  9



signal.c:


SZIGNÁL-LEKEZELÉS:


Saját szignálkezelõ fv. írása:

signal(SIGTERM,handler);   //SIGTERM szignál hatására a handler eljárás fut le
vagy:
signal(SIGTERM,SIG_IGN);   //handler = SIG_IGN - ignore the signal (not SIGKILL,SIGSTOP), 
                           //handler = SIG_DFL - back to default behavior   
pause();   //waits till a signal arrive 
printf("Signal arrived\n",SIGTERM);


Hogy lefusson maga a sima szignál-lekezelõ is:

//handler:
void handler(int signumber){
  printf("Signal with number %i has arrived\n",signumber);
  signal(SIGTERM,SIG_DFL);
  raise(SIGTERM);
}



SZIGNÁLKÜLDÉS:

kill(getppid(),SIGTERM);
//1. parameter the pid number of process, we send the signal
//    if -1, then eacho of the processes of the same uid get the signal
//    we kill our bash as well! The connection will close
//2. parameter the name or number of signal




A WAIT egy adott folyamat gyerekfolyamatának befejezõdésére vár,
a PAUSE pedig addig, ameddig nem kap egy megfelelõ jelzést

ps  -  összes processz megnézése

kill -SIGKILL 26577
kill -SIGTERM 26801


Háttérben való indítás: ./a.out &


Pl. a SIGKILL default mûködése nem írható felül (de sok szignálé igen)


raise(SIGTERM)  -  "magamnak küldök" SIGTERM szignált


Az ütemezõ miatt, ha valahol pause() van, akkor felmerül az a probléma, hogy ha akkor kerül elküldésre a szignál, amikor még nincs a másik folyamat a pause-nál, akkor nem fogja soha megkapni azt a bizonyos szignált, amit a pause elérése elõtt kapott
while ciklussal meg lehet oldani ezt a problémát (??)


Handler-ben nem illik printf-et használni



sigprocmask.c:

Jelzést akarunk blokkoloni és megfigyelni hogy mi történik a blokkolt jelzéssel (valamint feloldani a blokkolást).
Meg kell adni hogy melyik jelzéseket akarom blokkolni (a 32-bõl)

Konstrukció, struktúra ennek megoldásához
    sigset_t sigset;

32 bites szám, amelyik bit "be van billentve", azt blokkolom
2 féle alapállapot van:
- mindent blokkolok  -  sigfillset(&sigset);
- semmit sem blokkolok  -  sigemptyset(&sigset);

Szignál (most a SIGTERM) hozzásadása blokkolandó jelzések halmazához:
    sigaddset(&sigset,SIGTERM);
	
Törlés:
	sigdelset(&sigset,SIGTERM);


A struktúrában (sigset változó) lévõ szignálok blokkolása:
    sigprocmask(SIG_BLOCK,&sigset,NULL);  - ...
	    ...a NULL helyére meg lehet adni egy változót, amibe elmenthetjük a ... (????)
		//parameters, how: SIG_BLOCK, SIG_UNBLOCK, SIG_SETMASK -   ; 
		//2. parameter changes the signalset to this if it is not NULL,
		//3.parameter if it is not NULL, the formerly used set is stored here

		
Blokkolás feloldása:
    sigprocmask(SIG_UNBLOCK,&sigset,NULL);  -  ...
	    ...Feloldja a blokkolást, a korábban küldött szignálok most "érkeznek" meg
           ("The blocking of SIGTERM %i signal is released, so the formerly sent SIGTERM signal arrives.
	       SIGTERM is now released (not blocked further), the process will get it"
		   
sigsuspend(&sigset):
	pause() helyett lehet sigsuspend(&sigset)-et használni  -  blokkolja a (jelzéshalmazzal) megadott jelzéseket és vár egy jelzésre (amit éppen nem blokkol)
	"like pause() - except it waits only for signals not given in sigset. Others will be blocked"		   

		   

sigaction.c

  struct sigaction sigact;
  sigact.sa_handler=handler; //SIG_DFL,SIG_IGN
  sigemptyset(&sigact.sa_mask); //during execution of handler these signals will be blocked plus the signal
  //now only the arriving signal, SIGTERM will be blocked
  sigact.sa_flags=0; //nothing special behaviour
  
  //Szignál berakás:
  sigaction(SIGTERM,&sigact,NULL);
  sigaction(SIGUSR1,&sigact,NULL);
  //1. parameter the signal number
  //2. parameter the new sigaction with handler and blocked signals during the execution of handler (sa_mask) and a 
  //special sa_flags - it change the behavior of signal, 
  //e.g. SIGNOCLDSTOP - after the child process ended it won't send a signal to the parent 
  //3. parameter - &old sigset or NULL. 
  //If there is a variable, the function will fill with the value of formerly set sigset
	
	
	
	


Idõzítõ készítése rendszerszintû programokban
Unix-ban van több "timerelési lehetõség" (egyszerû esetben lehet egyszerût használni)

ITIMER_REAL  -  valós idõt mér
ITIMER_VIRTUAL  -  "CPU-ban eltöltött" idõt mér






Átkuldhetek sima szamot, de mutatot is (strukturara mutat -> ki tudom olvasni a mezöit a jelzeskezeloben)
rendszeridõ kezelése általában része a beadandónak és az évfolyamzh-nak is


sigaction_multiple:

Lényeg: ha olyan jelzést kap egy folyamat amit már megkapott (de még nem kezelt le), akkor azt kidobja  ->  ha túl hosszú az eseménykezelõ, elvesztünk szignálokat
De ez van ahol nem történhet meg -> a valós idejû jelzéserk prioritása nagyopbb -> azok biztos lekezelõpdnek (????)