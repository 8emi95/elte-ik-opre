bináris fájlkezelés

kell az elsõ beadandóban (a beadandó kb. fájlkezelésrõl szól)

a C++-os open fv itt is használható(??)
(...f.open()...)
DE:: Nekünk az alacsonyabb szintû bináris fájlkezelésre van szükségünk


Bináris fájlkezelés lényege:

Adott ponttól kezdõdõ bájtsorozattal dolgozunk:
Pl.: kiírunk 90 bájtot innentõl, vagy beolvasunk 90-et ide

Miért jó ez?  ->  nem kell adatkonverziókkal foglalkozni (mint magasabb szinten)
Mikor jó ez?  ->  Ha egy struktúrát akarok kimenteni (mert azt csak úgy simán nem lehet kimenteni, konvertálni kell (kivéve bin. fájlkezelésnél))

sizeof-al meg lehet állapítani a struktúra hosszát


Kommunikációnál is ezt használjuk (?), bitenként küldünk adatokat (?)



file.c:

RD_ONLY helyett szám is lehet, mert: ez igazából egy ilyen bitmaszk, amiben akkor van "bebillentve" egy bit, ha akarjuk a neki megfelelõ funkciót hasznáálni (pl.: ha írni is akarok, akkor az annak megfelelõ bitet is be kell állítani)

g=open(argv[2],O_WRONLY|O_CREAT|O_TRUNC,S_IRUSR|S_IWUSR);
O_WRONLY  -  csak írni akarom
O_CREAT  -  ha még nem volt, csinálja meg
O_TRUNC  -  ha már létezett, dobja el ("kezdje újra")
S_IRUSR|S_IWUSR  -  USR - user, R - Read-jog, W - Write.jog 
Itt is áll, hogy számot is írhatok: 600 jelenti ugyanezt (user ír, olvas, senki más nem csinálhat semmit)
(| a bitenkénti vagyolást jelenti)


read(f,&c,sizeof(c))
- honnan olvasok (melyik fájlból)
- hova (c ben nincs referenciatípus -> ez a c változó memóriacíme)
- a memóriacím mérete

write(g,&c,sizeof(c))
- hova írok (melyik fájlba)
- honann
- a memóriacím mérete

A read és a write is fv-ek
A read a sikeresen beolvasott bájtok számát adja meg (lehet pl.: 90 bájtot akarok beolvasni, de csak 40 van benne -> ez gond, tudnunk kell)

a c-ben nincs boolean típus (hamis=0, igaz=<minden más>)

write(g,&c,sizeof(c))!=sizeof(c)  -  akkor van probléma, ha nem sikerült annyit kiírni amekkora a kiíratott adat mérete


struct Structure s;  -  deklarálás


s.array = "valami";  -  ez egy jellegzetes hiba, nem lehet így értéket adni


karaktertömböket stringcopy-zni kell


a binaris fajlok sima szövegszerkesztõben nem olvashatok (beadandonal ezt is ellenorzi HBV, ha megnyitható, rossz)

fajlba íráskor nem tanacsos dinamikus memoriat allokalni





TÖBBSZÁLÚ PROGRAMOZÁS (????):


Új processz létrehozása kódból (duplikáljuk, klónozzuk a programunkat)  ->  "akár 180 példányban is futtathatjuk a programunkat"

Amikor létrejön a gyerek, onnantól kezdve váltogatva "mennek" a gyerekkel (idõszeletek vannak, az ütemezõ váltogat közöttük)
A szülõ dolgozik, létrehozza a gyereket, onnantól kezdve pedig váltakozva mûködnek

Új munkaterületet kap a gyerek, bemásolódik oda minden,a szülõben a fork elõtt létezõ változó, onnantól viszont két szeparált program fut


getpid  -  az aktuális processz-nek a process-id-ját adja vissza

[
ps aux | grep hbv (??)
ps ux

van egy adott pid érték, annál több folyamatot nem lehet létrehozni a programban
]

A pidszám kiosztása nem növekvõ sorrendben történik
az ütemezõ az elsõ szabad pid-et osztja ki
ez sokszor a következõ, de nem feltétlenül (pl. zh-n sokan futtatnak -> ...)

Amikor a szülõ befejezõdik, visszaadja az oprendszernek a "lehetõséget"  ->  az visszaadja a promptot
De: a gyerekek még futnak


Jellemzõ hiba: for ciklusban írjuk a fork()-ot  ->  ekkor nagyon nagy számú dolgot csinálok :)
Megoldás: csak akkor forkolok, ha a szülõben vagyok
Honnan tudom? -> megjegyzem a szülõ pidszámát és csak akkor forkolok, ha a folyamat pidszáma megegyezik azzal

A fork() visszaadja a gyerekfolyamat pidszámát
DE: a gyerekben ez null(a) lesz, mivel csak az másolódik át, ami a fork elõtt volt
Emiatt: Ha megjegyzem egy változóban, akkor vizsgálhatom hogy nulla-e. Ha igen -> gyerekben vagyok, ha nem -> szülõben


Példák:
* pid_t child = fork();
* fork();   //nem muszáj megjegyezni..
* if (child < 0)   //hibakezelés
  {
	  perror("Eror! The fork calling was not succesful\n");
	  exit(1);
  }
* if (child>0)   //szülõben vagyunk, "it can see the returning value of fork - the child variable!"
  {
	  waitpid(child,&status,0);   //waits for the end of child process PID number=child, the returning value will be in status
		     					  //0 means, it really waits for the end of child process - the same as wait(&status)
      printf("The value is %i in parent process (remain the original) \n",notacommonvalue);
  }
  else   //gyerek folyamatban vagyunk
  {
	  notacommonvalue=5;   //it changes the value of the copy of the variable
      printf("The value is %i in child process \n",notacommonvalue);
  }


Ha egy szülõ megszûnik a gyerekek megszünése elõtt, akkor zombi folyamatok jönnek létre
Az ilyen folyamatokra a rendszer az init folyamat pidszamat fogja szolgaltatni (ami mindig egy)
Ezt a waitpid(child,&status,0);  segítségével lehet megakadályozni (??)


Szülõ pidjének lekérdezése: getppid()  (ha 1-et ad  ->  a szülõ már nem fut)




ALVÁS:

usleep(20);   //waits 20 milisec
sleep(3);

What is the difference?
"sleep(3) is a posix standard library method that attempts to suspend the calling thread for the amount of time specified in seconds. usleep(3) does the same, except it takes a time in microseconds instead. Both are actually implemented with the nanosleep(2) system call."




RANDOM SZÁMOK:

srand(time(NULL));   //the starting value of random number generation
int r=rand()%100;   //number between 0-99
printf("Random number %i\n",r);




Kisfeladat:
Pontosan 2 gyereke legyen egy folyamatnak (a két fork nem jó, mert lesz 2 gyerek, meg az egyiknek a gyereke)