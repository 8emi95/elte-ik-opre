<signal.h>

sigset_t
sigemptyset(&sigset)
sigfullset(&sigset)
sigaddset(&sigset, signal)
sigdelset(&sigset, signal)
sigprocmask(művelet, &sigset, &oldset)

SIG_BLOCK
SIG_UNBLOCK
SIG_SETMASK

struct sigaction
    sa_handler:     handler 
                    SIG_DEL
                    SIG_IGN
    sa_mask:        sigset_t
    sa_falgs:       O: alap
                    SA_SIGINFO: nincs beállítva: void handler(int signo)
                                ha be van állítva: void handler(int signo, siginfo_t *info, void *context)

sigaction(signum, &act, &oldact)
sigsuspend(&mask)

SIGRTMIN
SIGRTMAX

SIGRYMIN
SIGRTMIN+1

-lrt kapcsoló

raise(signal)

<unistd.h>
alarm(másodperc) -> SIGALARM

<sys/time.h>
struct itimerval
        -it_interval
        -it_value

struct timeval
        -tv_sec
        -tv_usec
    (összeadódnak az értékek)

settimer(időzitő, &újtimer, &regitimer)
    ITIMER_REAL
    ITIMER_VIRTUAL
    ITIMER_PROOF

hogyan 
miért írja ki 

union a {
    tipus1 adattag1;  int i;
    tipus2 adattag2;  char c;  
}

a.i, a.c

gettimer(időzitő, &timer)

info->si_code
info->si_pid
info->si_value : int: info->si_value.sival_int
                 ptr:               .sival_ptr

sigqueue(PID, signal, value)

<time.h>
timer_create(clockid, &signalevent, &timerid)
    clock id:       CLOCK_REALTIME
    signalevent:    sigev_notify:   SIGEV_NONE
                                    SIGEV_SIGNAL
                    sigev_signo:    
                    sigev_value: 
                    timer_id:

itimerspec

timer_settime(timer_id, flags, &ujtimer, &regitimer)
                            0
timer_gettime(timer_id, &act_ertek)ű
timer_delete(timer_id)

sigaction_value;

100 strcpy(zoli.name, "Fradi");
101 zoli->küldjük,
