Operációs Rendszerek 2. Gyakorlat Jegyzet

Gyakorlat weboldal: klettner.web.elte.hu  --> Oktatás (Időbeosztás)

String tömb deklarálása:
	 char str[20] --> 19 hosszú stringet adhatunk csak meg, mert szükség van a '\0'-nak egy helyre
	 char str2[] = "Hajrá Vasas!"; --> 13 nagyságú tömb
	 Az 'str' és az 'str2'típusa mutató
	 str = "Hajrá Újpest!" --> Hibás, nem megengedett	
		Megoldás:#include <string.h>
			 Műveletek: strcpy(cél_mutatója, forrás_mutatója)						Pl.: strcpy(str, str2);
			      strcpy(str, "Hajrá Fradi!");

Mutatók:
	 * -- érték
	 & -- címe

	 char* ptr_str, p_str2; --> Itt a p_str2 sima char, nem mutató
		Megoldás: char *ptr_str, *p_str2;

	 ptr_str = &str[0]; --> Mutató beállítása egy változóra
		Egyszerűbben: ptr_str = str; --> Ugyanaz mint fentebbi hiszen az str, a tömb első elemére mutató mutató.

Hivatkozások:
	ptr_str == &ptr_str[0]; --> Első karakterre mutat
		   &ptr_str[6]; --> Hetedik karakter
		   ptr_str+6; --> Hetedik karakter

Elemre hibatkozás:
	Kiakarom venni a 0. elemet: ptr_str[0] == *ptr_str;
	12. karakterre szeretnénk hivatkozni: ptr_str[11] == *(ptr_str+11) 


DINAMIKUS MEMÓRIFOGLALÁS

	Szükségünk lesz az 'stdlib.h'-ra, és ennek a 'malloc()' függvényére.
		-Szintaxis: malloc(byte_érték_ami_a_lefoglalandó_mennyiség); --> Ha sikerül, egy memória címet ad vissza, ha sikertelen akkor nullát.	
	char *s;
	¤ s = malloc(20); --> s = (char*)malloc(20*sizeof(char)); : Jelzem hogy ez egy character típusú mutató és jelzem, hogy a típus méretének a 20-sát szeretném lefoglalni. Ez a szakszerű használata.
			--> (( == char s[20] --> Fontos különbség hogy a char s[20]-t a blokk végén oldja fel a program, míg a malloc-al lefoglalt helyet nekünk kell felszabadítani.))

	¤ free(mutató) --> free(s); :  Felszabadítja azt a memória területet. Ha pl. nagyobb hely kell. Hátránya azonban, hogy itt elveszik az információ amit az s-ben tároltunk.

	¤ realloc() --> mutató = (char*)realloc(mutató,mennyiség*sizeof(típus)) : A 'mutató' az előző helyfoglalásra mutat, nem az a mutató aminek értékül adtuk. Megpróbálja lefoglalni az új memóriaméretet. Ha ez nem sikerül, ez is nullát fog visszaadni, az eredeti mutatóba viszont ilyenkor is benne marad az érték. Memória szemetet termel ha marad szabad hely, és felszabadítja a régi helyet(ha sikeres).

Stirng fában lévő szükséges függvények (string.h)
	¤ strlen(mutató) --> A string tényleges hosszát fogja megadni(nem keverendő a sizeof-al).
	¤ strcmp(mutató1, mutató2) --> Összehasonlítja a két stringet. Eredménye negatív(első a kisebb), nulla(egyenlő) vagy pozitív(második a nagyobb). Eredmény: -2 --> Hogyha első karakter pl 'A' második 'C'.
	¤ strcar(cél_string_mutató, forrás_string_mutató) --> A forrást hozzásfűzi a cél végéhez.

Feladat: strleng függyvény készítése, eredményként pedig adja vissza, hány karakter hosszú a string
		int length(...)

Házi Feladat:
	1. Órán csinált
	2. Egyenlőség vizsgálat stringekre. !0 : Egyezik , 0 : eltér
	3. Foglaljunk le területet egy char*-nak, adjuk értékül egy másiknak, majd ellenőrizzük, hogy nem ugyanoda vannak foglalva.
