fseek(t, elmozdulás byte, viszonyítási pont) --> Ha hiba van akkor nem nulla a visszatérési értéke.
		-- Viszonyítási pont három érték lehet: ¤ SEEK_SET --> fájl elejétõl --> inkább pozitív
							¤ SEEL_CUR --> mutató aktuális pozicíója --> pozitív vagy negatív érték
							¤ SEEL_END --> fájl végétõl

Fájlkezelés Rendszerhívások alkalmazásával:
	¤ Csak bináris fájlkezelést tudunk vele csinálni
	¤ Nem muszáj includeolni, de a konstansok a <tentl.h>-ban vannak
	¤ Szintaxis: int f = open(fájl_név, mód)
		         f = open(fájl_nv, mód, engedélyek) --> Sikertelen megnyitás -1; Sikeres hívás esetén a nullához legközelebbi 
pozitív számot adja vissza.
	¤ Módok(vagyokkal több megadható): O_RDONLY
		 			   O_WRONLY
		 			   O_RDWR
		                 	   O_APPEND
		 		           O_TRUNC
	         			   O_CREATE --> Itt kötelezõ megadni az engedélyeket
		 			   O_EXCEL --> O_CREATE-el együtt használatos, mert létre kell hozni

	¤Engedélyek: S_I[R|W|X][USR|GRP|OPH] pl.: S_IROTH --> O_CREATE-nél kell megadni
	¤Lezárás: close(fájl_azonosító)
	¤Olvasás: read(fájl_azonosító, kezdõcím_ahová_olvasom, olvasandó_bájtok_száma) 
				--> Visszatérési értéke az olvasott bájtok száma. Hiba esetén negatív.
	¤Írás: write(fájl_azonosító, kezdõcím_ahivá_írom, kiirandó_bájtok_száma)
				--> Visszatérési értéke a kiiírt bájtok száma.
	¤Pozicionálás: lseek(fájl_azonosító, elmozdulás_bájtban, viszonítási_pont)
				--> Ugyanúgy SET,CUR,END

HF.: Ugyanazt a progit amit órán megírtunk, ezzel is megírni.
Példák: directory.c --> könyvtárkezelés példa
	open_fopen.c --> fájl írás
	file.c --> Írás olvasás
	mtime.c --> Egy fájl létrehozási és módosítási idejét tudja lekérdezni (idõkezelés)
 	password.c --> Lekérdezni ki a tulajdonosa egy fájlnak

------------------------------()--------------------------------------()---------------------------------------()------------------

FOLYAMATOK

Amikor létrehozunk egy új folyamatot akkor egy meglévõ folyamatot - amiben már benne vagyunk - dupláz meg, így mindenrõl csinál egy 
másolatot. Ennek ellenére ez a két folyamat szinte teljesen eltér egymástól csak egy minimális összeköttetés van, hogy tudjanak
egymásról.

	¤Mûködése: Szükségünk van a <sys/types.h> --> 'pid_t' típus van benne, ami egy folyamat-azonosító
	¤Rendszerhívások: -ban van egy fork() --> ez létrehoz egy gyerekfolyamatot, ami csak PID és PPID értékben tér el a szülõtõl.
Tehát ez után két szinte teljsen ugyanaz folyamatunk van, egy szülõ és egy gyerek. A fork() visszatérési értéke a gyerekfolyamat 
child PID (ez a szülõben található meg, a gyerekben ennek a visszatérési értéke 0).
			  getpid() --> maga a folyamat azonosítóját adja vissza
			  getppid() --> a szülõ folyamat atonosítóját adja vissza

	¤Mellékes folyamatok: sleep(másodperc) és usleep(mikorsecund) --> Felfüggeszthetjük a folyamatok végrehajtását.

Feladat: Legyen egy szülõ, indít két gyereket, a gyerekek kiiírják a saját és a szülõ PIDé PPID-jét,
a szülõ pedig kiírja a gyerekek PID-jét

	¤Még pár hívás: wait(&status*int típusú*) --> felfüggeszti a szülõfolyamaotot amíg be nem fejezi a megadott gyerek folyamat
a futását.					  --> Visszatérési értéke: Ha hiba, mínusz 1. 
									   Ha jó, annak a gyereknek a pid-je amelyik leállt.
			waitpid(pid_érték, &status, options*int típusú*) --> Felfüggeszti a folyamat végrehajtását, amíg a megadott
gyerekfolyamat !állapota! meg nem változik. Ha a pid_érték = -1, az az összes gyerek folyamatra vonatkozik.
									 --> Visszatérési érték: Ha hiba, -1.
									 --> Ha jó, a gyerek pid-je, aminek az állapota változott.
									 --> options helyére gyakorlatba mindig null-t írunk, de itt
megadhatjuk, hogy melyik állapotváltozásokra figyeljen: WNOHANG(terminál, ez a null)
							WUNTRACED(leállt)
							WCONTINUED(folytatódott)