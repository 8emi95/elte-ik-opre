Honalpon lehet jelenzni ha konzultációra jönni szeretnénk.

char**
main(int argc, char **argv)
  argv[0] : futtatása
  [1]...[argc-1] : paraméterek
  [argc] : Null


----------------------------------------------------------------

Struktúrák:
  Szintaxis:
	struct típusnév{
	  mezőtípus1 mezőnév1;
	  ...
	  ...
	  ...
	  mezőtípusN mezőnévN;
	} 
	
	struct típusnév azonosító;
	azonosító.mezőnév;

	struct típusnév *ptr{
	  (*ptr).mezőnév; (<-- Egyszerűbb módszer, ekvivalens -->) ptr->mezőnév;
	}


----------------------------------------------------------------

Hibakezelés:
  <errno.h>:
	errno -> C-ben int C++-ban makróként szerepel
		 STD lib-ben bármi módosíthatja
		 Újból bekövetkező hiba felülírja a korábban bekövetkezett hibát

  <stdlib.h>
	perror(saját_hibaüzenet_szöveg) -> errno-ban tárolt hibaüzenet így is kitudjuk iratni, nincs szükség include-olni az errno.h-t

-----------------------------------------------------------------

Fájlkezelés
  <stdio.h>:
	FILE -> p1.FILE *f;
	Függvények:
	  fopen
	  fclose
	  fseek
	  feof
	Két megnyítási módszer:
	  Megnyithatjuk fájlként vagy bájtkódként is.
	  Szöveggként(text):
	    fprintf
	    fputs
	    fgets
	  Bináris mód(bin):
	    fwrite
	    fread

	Megnyitás:
	  f = fopen(fájl_név, mód) -> Ha sikrtelen: f == Null
			    	      Ha sikeres: pointert kapunk a fájl elejére.

	Lezárás:
	  fclose(f)

  -Szöveges fájlkezelés:
    ¤ Megnyitási módok:
	"r"
	w --> Mindenképpen létrehozza
	a --> Csak akkor hozza létre ha nem létezik
	rt --> Olvasásra és írásra megnyitás
	wt --> Új fájlt hoz létre olvasási és írási jogokkal
	a+ --> Olvasásra és hozzáadásra nyitja meg és ha nem létezik, létrehozza

    ¤ Írási módok:
	Null karakter nem kerül bele szöveges fájlba
	fputs(string_amit_belekarunk_tenni, fájl_pointer) --> negatív értéket ad vissza, ha nem sikerült az írás
					 		  --> siker esetén nincs dediniált érték (ha nem negatív akkor sikeres volt)
	fprint(fájl_pointer, form_string, változólista) --> Olyan mint a printf, csak az elejére beteszünk egy fájl pointert.
							--> A kiírt karakterek számát adja vissza eredményül

    ¤ Olvasási módok:
	fgets(mutatója_a_stringnek_ahová_olvasni_akarunk, max_beolvasandó_karakterszám, fájl_pointer) --> Null értéket ad vissza
 ha nem tudott beolvasni
												      --> Ha tud olvasni akkor annyit
 ad vissza mint amennyit mi megadtunk neki					
												      --> Ha eléri a fájl végét, 
abbahagyja a működést

    ¤ Fájl végének a kezelése:
	feof(fájl_pointer) --> Az értéke nem nulla ha a fájl vége után próbálunk olvasni, fontos, hogy nem a fájl végén ad vissza igazat
 hanem csak a fájl vége után. |fájl_eleje||_| ...  |fájl_vége||eof|

    

    ¤ <unistd.h>
	access(fájlnév, mód) --> Nullát ad vissza ha az elérés engedélyezett és egyet ha nem
	  R_OK --> Olvasási jog
	  W_OK --> Írási jog
	  X_OK --> 
	  F_OK --> Létezés ellenörzése (R,W,X egyesítése)


  -Bináris Fájlkezelés  
	Egy tömb elemeit írja fájlba, független az elemtípustól.
	Módok:
	  Ugyanaz mint szöveges fájlnál, csak második karakter 'b' mindig (pl "rb" ...)
	  Írás: 
	    -fwrite(első_elem_kezdőcíme, elem_méret, elem_szám, fájl_pointer) --> Visszatérési értékül a tényleges elemszámot adja
	  Olvasás:
	     -fread(paramétereit ugyanazok mint az 'fwrite'-nak) --> Értékei a ténylegesen beolvasott elemek száma
	  Tömb fetöltése(elem típustól független) 
		Tömb t;
		fread
		         (t, sizeof(t[0], sizeof(t)/sizeof(t[0]), fájl_azonosító)
		fwrite
	  Változó értékét akarom kiírni/beolvasni
		Változó v;
		fread
			(&v, sizeof(v), 1, fájl_azonosító)
		fwrite

Házi Feladat(Honalpon fentlesznek majd):
	¤ Duplázás javítása open_fopen-ben (bináris beolvasásnál)
	¤ Készítsünk egy olyan programot mely egy két mezőből álló struktúrát hoz létre (int, char) és ebből csinál egy const n
elemű tömböt. Az ,n'-re az igaz hogymindenképpen páros. A char 'a'....n.-dik karakterig feltölti, az intet pedig 1...n-ig, tehát a 
tömb első eleme 'a és 1';'b és 2';...;'n-dik char és n' A végeredményt írja ki egy fálba, majd ezután olvassa vissza a fájlból a tömbbe, kettesével úgy, hogy 
visszafele töltse vissza az adatokat.


