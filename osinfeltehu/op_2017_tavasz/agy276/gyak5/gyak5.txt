5. Gyakorlat 2017.04.24.

SZIGNÁLOK
	- Maszkolás: Maszkot csinálunk a szignáloknak, amik a maszkban vannak azok nem jutnak el, de nem is vesznek el (várnak hogy bejussanak)
	- signal.h -> sigset_t : Szignálok halmaza. 
		¤ Deklaráció: sigset_t sigset;
		¤ Makrók: sigemptyset(&sigset) -> Inicializálja és üressé teszi a szignál készeltet
			  sigfullset(&sigset) -> Inicializálja és hozzáadja az összes szignált a készlethez (összeset blokkolja)
			  sigaddset(&sigset(amihez_hozzá_akarjuk_adni), signal_amit_hozza_akarunk_adni) -> signált hozzáadja a készlethez
			  sigdelset(&sigset, signal) -> eltávolítja a signált a készletbõl
			  sigprocmask(mûvelet, &sigset, &oldset) -> Beállítja a signálok blokkolását egy adott mûveletre. oldset: Kimenthetjük az elõzõ maszkolást(állapotot), NULL is lehet. Utána 
visszaállíthatjuk az erdeti maszkolás. Visszatérési értéke, 0 ha sikeres, -1 ha nem sikeres
				-Mûveletek: SIG_BLOCK ->  Hozzáadja a sigset-be lévõ signalokat a jelenleg érvénybe lévõ maszkhoz
					    SIG_UNBLOCK -> Eltávolítja a sigset-be lévõket a maszkból (eddig blokkoltak nem lesznek blokkolva)
					    SIG_SETMASK -> Ténylegesen csak azok lesznek blokkolva amik a sigset-be vannak
		¤ Kivételek: SIGKILL, SIGSTOP --> Ezek nem maszkolhatók | Nem blokkolhatók
		¤ Sigaction ->  Sigaction és signal egyidejû használata nem javasolt egy programon belül. 
				Szintén a <signak.h> -ban van
				Eseményleíró struktúra
					struct sigaction
						¤ sa_handler : handler belépés pontja |VAGY| SIG_DEL |VAGY| SIG_IGN
						¤ sa_mask: sigset_t (típusú) -> A további végrehajtó szignálokat a handler végrehajtása során blokkoljuk. Blokkolva lesznek a handler alatt minden olyan
signál amik elindították a handlert + az sa_mask-ba átadott signalok + az a signal is blokkolva lesz ami kiváltotta a handlert
						¤ sa_flags -> A signal viselkedését meghatározó flagek. 0: alapviselkedés 
												      SA_SIGINFO : bit, ami 
							Ha nincs beállítva akkor a handler ugyanaz a felépítésû handler, mint amit eddig megismertünk. Ha nincs beállítva, akkor a handler
 szintaxisa: void handler(int signo).
							Ha be van állítva: void handler(int signo, siginfo_t *info, void *context)
							A siginfo-ból tudjuk meg mi az ami kiváltotta signalt
							info -> si_code
							info -> si_pid --> Ki küldte
							info -> si_value --> Signallal küldött únió típusú információ. Ez lehet egy int típusú egész szám: info -> si_value.sival_int 
																					vagy
																    pointer típusú:	   info -> si_value.sival_ptr
							¤ <signal.h>
								- sigqueue(PID, signal, value) -> kinek küldöm, szignál maga, únió
							¤ Idõzítõvel való signal küldés
								- <time.h> : 	
									¤ timer_create(clockid, &signalevent, &timerid) -> Létrehoz egy új idõzítõt: 
										clockid határozza meg hogy milyen óra szerint idõzít (CLOCK_REALTIME ....) 
										signalevent -> sigevent típusú struktúra: Adattagjai: 
											sigev_notify: SIGEV_NONE -> Nem történik semmi
												      SIGEV_SIGNAL -> Signált küld
											sigev_signo
											sigev_value: únió típusú, amit a handlernek elküldtünk
										timerid: timer_t, kell mert több timert is indíthatunk
									¤ itimerspec: Idõzítõ struktúra -> Hasonló (kb ugyanaz) mint az elõzõ
									¤ timer_settime(timerid, flags (0 általában), &új_timer, &régi_timer)
									¤ timer_gettime(timerid, &aktuális_érték_struktúrája)
									¤ timer_delete(timerid)



						¤ sigaction(signum, &act, &oldact) -> act és az oldact sigaction típusú struktúrák. 'act' új kezelési mód, 'oldact' az addig érvényben lévõ kezelõ mód 
leírója. Nem csak beállításra de kiolvasásra is alkalmas(act-ra NULL-t írunk, oldact visszaad)
						¤ sigsuspend(&mask) --> Azt a folyamatot amibõl ezt meghívjuk annak a signal maskját lecseréljük arra amit itt megadunk. Ezután felfüggeszti, amíg nem
kap olyan signal-t amit mi megadtunk (egy bizonyos signal várunk, csinálunk egy olyan maskot ami csak ezt a signal-t tárolja). Amikor a várt signal bejön, továbbengedi a folyamatot.


VALÓS IDEJÛ SZIGNÁLOK
	- Ahányat küldünk belõle az mind sorban fog állni
	- SIGRTMIN és a SIGRTMAX közé esõ szignálok a real time signals	
	- SIGRTMIN, majd SIGRTMIN+1 .... De mindig ellenõrizni kell nem léptük e túl a SIGRTMAX-ot
	- Ezeket csak mi válthatjuk ki
	- Magasabb prioritásúak, így elõbb is kerülnek kiszolgálásra
	- Azonos típusú valós idejû szignálok kiszolgálása a küldési sorrendtõl függ, ha eltérõek, akkor az alacsonyabb számú a magasabb prioritású, mindegy milyen sorrendben érkeztek.
	- Rendszerfüggõ hogy hány signal áll rendelkezésre (ne használjuk szimbólikus konstansokat)
	- '-lrt' --> 'gcc 5.c -lrt' a helyes fordítási szintaxis (biztonság miatt)
	- <signal.h> --> 
		¤ raise(signal) -> Önmagának küld egy signalt

IDÕZÍTÉS
	- sleep() -> nem megbízható, mert bármilyen signal leállítja. Ha pedig bármilyen funkciós késletet, a sleep nem tud továbblépni
	- idõzítõ -> signalt küld a folyamatnak ha lejár az idõ, így nem blokkolja a folyamatot.
		¤ alarm(másodperc_idõ) -> ha eltelt az idõ, küld egy SIGALARM-t. Ha 0-át adunk meg másodpercnek akkor leállítja az idõzítõt, így megszakítható az idõzítõ.
	- <sys/time.h>
		¤ struct itimerval
			_it_interval
					--> Mindkettõ timeval típusú
			_it_value
		
		¤ struct timeval
			_tv_sec --> másodpercben megadott
			_tv_usec --> mikrószekundumban(?) megadott

		¤ timeval -> _tv_sec és _tv_usec összeadódik és együtt képviselnek egy idõértéket. 
		¤ interval -> újraindított érték mivel induljon
 		¤ value -> az elsõ indulás meddig tartson -> tehát ha az interval nem nulla, akkor újraindítja az idõzítõt.
		¤ Beállítása: settimer(idõzítõ, &új_timer, &régi_timer) --> Értéke: 0, ha sikeres | -1, ha hiba
			- ITIMER_REAL -> Valós idõt méri -> SIGALARM-ot küldi. Az alarm(0) ezt is törli
			- ITIMER_VIRTUAL -> Adott folyamat amiben az idõzítõt indítottuk, mennyi ideig fut -> SIGVTALART-ot küldi
			(- ITIMER_PROOF -> Csak érdkesség képp -> SIGPROOF-ot küldi)
		¤ gettimer(idõzítõ, &timer) -> Lekérdezhetõ a timer értéke

setitimer.c megnézési otthon! (gyak5-ben van). Kérdések: ¤ Hogyan állítja le a handler_settimer a programot?
							 ¤ Mit csinál a 18. és 19. sora?
							 ¤ Miért írja ki a "0 seconds"-ot?
sigactionvalue.c megnézni otthon. Kérdések: ¤ Hogy mûködik?
					    ¤ A 100. sorban ha 'zoli' helyett 'who' struktúrát küldjük, akkor mûködik, de hogyha az adamot küldjük akkor rossz lesz, mi okozza a problémát?
					    ¤ Ha még beinclude-oljuk a <string.h>-t és a 100. sorba beszúrjuk, hogy "strcpy(zoli.name, "Fradi"), 101. sorban pedig zoli->küldjük, akkor mi íródik ki
és miért?

ÚNIÓ TÍPUS
	- Speciális típus ami lehetõvé teszi hogy különbözõ típusú adatokat tároljunk ugyanazon a memóriacímen.
	- Tetszõleges számú adattaggal definiálható, de egyszerre csak egy adattag értékét veheti fel.
	- Ha értéket kap, akkor annak a típusnak megfelelõen kezeli a memóriafoglalást.
	- Deklaráció:
		union a {
		  típus1 adattag1; //int i
		  típus2 adattag2; //char c
		}