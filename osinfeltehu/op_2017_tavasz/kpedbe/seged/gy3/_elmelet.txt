Házi feladat:
 1. Névtelen cső: 
 - Írja be egyik folyamat a csőbe a parancs paramétereit, 
		megfelelő elválasztással, míg a másik folyamat olvassa ki azokat!
		
2. Nevesített cső:
- 5 darab random szám beírása a csőbe és kiolvasás (számmá alakítás)
- struct coord {int x, int y}; beírása és kiolvasása

3. Select, Poll
- Szülő-gyerek folyamatok "beszélgessenek" egymással, amíg egyik be nem fejezi a beszélgetést!



Egyirányú cső:
http://www.cs.ubbcluj.ro/~laura/so2/dokumentacio/pipe.htm
Nevesített cső:
http://www.cs.ubbcluj.ro/~laura/so2/dokumentacio/fifo.htm

Cső (pipe) (név nélküli)
Jellemzői:
•	félduplex
•	csak közös őssel tudjuk használni, mert örökölt file-ként érik el a gyerekek
Az adatokat átmenetileg a kernelben tárolja, véges bufferhosszal. 
Ha valamelyik résztvevő folyamat nem tud írni vagy olvasni, azt megvárakoztatja.

int  pipe (int filedes[2]); (==0: OK, ==-1: hiba)
Létrehoz egy csövet, és meg is nyitja, tehát nem kell utána open() -el megnyitni
•	filedes[0]: olvasható read-del (mint egy file)
•	filedes[1]: írható write-tal (mint egy file)

Tipikus használat
Szülő ill. gyerek között adatok továbbítása: a szülő csinál csövet a gyerek indítása (fork) előtt, 
mert az örökli, mint egy megnyitott file-t. Az egyik processz adott csövön csak ír, másik csak olvas,
hogy a két irányon az üzenetek ne keveredjenek. Ha a másik irány is kell, újabb csövet használunk.


 
 
FIFO (cső névvel)
Jellemzője:
•	független processzek között is, nem kell közös ős
A csőnek neve van, mely bele kerül a file táblába, bárki megnyithatja, akinek joga van hozzá.

int  mkfifo  (const char *pathname,  mode_t mode);
	pathname	A fifo neve, mint file
	mode		Megnyitási mód, mint open-ben.
/* 
Visszatérési érték: 
		= 0   :OK, csak a név bejegyzése történt meg, használat előtt open kell 
		= -1  :hiba
*/

Használata
Open, close, read, write: mint egy file. Amíg nincs partner, a megnyitó folyamat vár 
(normál, tehát blokkoló megnyitásnál), írásnál SIGPIPE signalt kap az író folyamat. 
Többen is írhatják "egyidejűleg", ezeket a rendszer fifo sorrendben továbbítja. 
Mivel egy írás (write) atomi művelet, egy-egy írás adatai nem keveredhetnek össze. 
Ha minden író lezárta, EOF-t (0 db. byte olvasása) kap az olvasó.
Ha nem-blokkolóra nyitjuk meg (O_NONBLOCK), akkor csak olvasásra való open azonnal visszatér, 
de a csak írásra való megnyitás, ha a másik végét még nem nyitották meg, hibával tér vissza, errno=ENXIO.






SELECT
Léteznek olyan rendszerhívások, melyek egyszerre több I/O tesztelésére is használhatóak, és akkor adják vissza a vezérlést, 
ha legalább az egyik I/O-ban változás történt.

int select (int 			maxfdp,      /* legnagyobb, általunk használt file leíró +1 */
            fd_set         	*read_fds,    /* vizsgálandó olvasott file leírók halmaza */
            fd_set         	*write_fds,   /* vizsgálandó írott file leírók halmaza */
            fd_set         	*except_fds,  /* vizsgálandó kivételes állapotú (exception) file leírók halmaza */
            struct timeval 	*tvptr);      /* time-out érték, vagy NULL */

/* 
Visszatérési érték: 
	-1 : hiba, pl. signal érkezett I/O befejeződése előtt;
	 0 : time-out történt I/O befejeződése előtt;
	>0 : a kész leírók összes száma 
*/

FD_ZERO  (fd_set *fdset);            /* minden bit törlése, ez a kötelező inicializálás */
FD_SET   (int fd, fd_set *fdset);    /* adott bit bekapcsolása */
FD_CLR   (int fd, fd_set *fdset);    /* adott bit kikapcsolása */
FD_ISSET (int fd, fd_set *fdset);    /* adott bit benne van a halmazban? */

Ha nem tudjuk előre, mekkora lesz a max. file-leírónk, akkor használhatjuk az FD_SETSIZE értéket is,
de ez általában túl nagy, pl. 256 vagy 1024. A megnyitott legnagyobb file leírót megadja:  int open_max();
Csak akkor van értelme a halmazok vizsgálatának, ha a visszatérési érték pozitív, egyébként azok tartalma meghatározatlan. 

Ha a visszatérési értékben adott file-leíró benne van, akkor azon végzett I/O műveletet további várakozás nélkül végre lehet hajtani.
A kivételes állapotok megvalósításfüggőek, lehet pl. adattorlódás (=out of band) esemény adatátviteli vonalon.
Ha file végét érzékel a rendszer adott file esetén, az nem kivételes állapot, de az olvasás 0 értékkel fog visszatérni, mint rendesen.
