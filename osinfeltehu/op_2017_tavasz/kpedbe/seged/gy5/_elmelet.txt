http://www.tankonyvtar.hu/hu/tartalom/tamop412A/2010-0011_szamalap2/hu/tartalom/tamop412A/2010-0011_szamalap2/lecke11_lap3.scorml
http://www.tankonyvtar.hu/hu/tartalom/tamop412A/2010-0011_szamalap2/hu/tartalom/tamop412A/2010-0011_szamalap2/lecke10_lap3.scorml
http://www.tankonyvtar.hu/hu/tartalom/tamop412A/2010-0011_szamalap2/hu/tartalom/tamop412A/2010-0011_szamalap2/lecke11_lap1.scorml

Üzenet-sor (message queue)
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>
	
Megnyitás: újat, vagy létezõt
	int msgget (key_t kulcs,  int flag)
		>0: azonosító, -1: hiba
		flag: hozzáférési jogok (mint file, de x, azaz végrehajtás nincs)

Mindenféle beállítások
	Állapot lekérdezése, beállítása, megszüntetés 
	(parancs = IPC_RMID, utána további hivatkozás rá EIDRM hibát ad).
    int msgctl (int azonosító,  int parancs,  struct msgid_ds * buf);
		parancs:
		- PC_STAT: az üzenetsor adatainak a lekérdezése a harmadik paraméterben megadott címre.
		- IPC_SET: az üzenetsor adatainak a módosítása a harmadik paraméterben megadott tulajdonságokkal.
		- IPC_RMID: törli az üzenetsort.
		

Küldés
	Betesz egy üzenetet a sor végére. 
    int msgsnd (int azonosító,  const void *cím,  size_t hossz,  int flag);
		= 0: OK, -1: hiba
		Az üzenet elejérõl egy long int >0 típust vesz fel, ami alapján keresni is lehet majd msgrcv-vel.
		Ezt követi a hossz db. Byte. 
		flag-ben IPC_NOWAIT: azonnal visszatér, ha nem sikerült, pl. mert a sor tele van, errno = EAGAIN.
		Ha közben a sort törlik: EIDRM (Error: Identifier Removed) hiba, ha közben signal jött: EINTR hiba. Ilyenkor pl. újra lehet kezdeményezni a mûveletet.

Fogadás
	Kivesz egy üzenetet, a folyamat alapesetben blokkolódik, ha nincs üzenet.
    int msgrcv (int azonosító,  void * cím, size_t maxh,  long típus, int flag);
		>= 0: adatok hossza,  -1: hiba
		ha maxh -nál hosszabb lenne, E2BIG hibát ad, kivéve, ha flag-ben MSG_NOERROR bit van, ekkor csonkítja. 
		típus:
		== 0  : elsõt veszi elõ (típusától függetlenül)
		> 0  : elsõ ilyen típusút veszi elõ (pl. kliens- szerver közötti 2-irányú kommunikáció egyetlen sorral, típus azonosítja címzettet
		< 0  : elsõ (-típus) -nál kisebb típusút veszi elõ  (pl. prioritás kezelésére)
		flag:
		= IPC_NOWAIT: azonnal visszatér
		Ha nem sikerült, hiba = ENOMSG: nincs (ilyen) üzenet, többi hiba: mint msgsend -nél
		Az adatokat 2-szer is másolja a memórában, ezért lassabb, mint közös memória.

Érdemes megjegyezni, hogy minden file-hoz tartozik egy-egy hivatkozás-számláló, 
mely 1-el csökken, amikor lezárják a file-t, és a file csak akkor törlõdik ténylegesen, ha  a számláló 0 lesz.
Itt és a szemfornál azonban egy törlés azonnal megszünteti az eszközt, a többi patner csak a következõ mûvelet sikertelenségébõl értesül errõl. (A közös memóriánál nem.)





Megosztott memória kezelése 

- Létrehozása (shmget)
- Lekérdezése, módosítása és törlése (shmctl)
- Memóriarész hozzárendelése (shmat)
- Memóriarész hozzárendelésének megszüntetése (shmdt)


A megosztott memória (shared memory) a folyamatok közti kapcsolattartás egyik 
leghatékonyabb eszköze. A módszer lényege, hogy a folyamatok közös memóriate- 
rületen keresztül tartják a kapcsolatot. 
Az eddig tárgyalt memóriafoglalási módszerek nem alkalmasak megosztott me- 
móriaterületek foglalására, hiszen az általuk kezelt memóriaterületeket csak egy fo- 
lyamat használhatja — amelyik azokat lefoglalta. Amíg ez a folyamatok egymástól 
való védelme szempontjából szükséges, a folyamatközi kapcsolattartás (IPC, inter 
process communication) támogatására hasznos a megosztott memória kezelése, hi- 
szen nincs még egy olyan gyors eszköz, mint az operatív memória. 
A következõkben a legfontosabb függvényeket vesszük sorra, amelyek megosz- 
tott memória kezelésére szolgálnak Linux rendszereken. Ezeknek az eszközöknek a 
használatához szükség lehet a sys/types.h, sys/ipc.h és a sys/shm.h fejállomá- 
nyok betöltésére. 

key_t f tok (const char *állomány, int változat) ; 
	A függvény különleges azonosítót hoz létre, amely a folyamatok közti kapcso- 
	lattartás folyamán használatos. Valójában a függvény igyekszik egyedi azono- 
	sítót készíteni, amely lehetõvé teszi, hogy a folyamatok közt kiépített kapcso- 
	latok ne keveredjenek össze egymással. 
	Az azonosító létrehozásához a függvény felhasználja az elsõ paraméterként 
	kapott állománynevet és a második paraméterként kapott változatszámot. Az 
	állománynévnek létezõ állományra kell mutatnia, mert a függvény az állo- 
	mányt megnyitja és onnan információkat nyer. A függvény az állománynevet 
	és a változatszámot arra használja, hogy az alkalmazásra jellemzõ egyedi azo- 
	nosítót hozzon létre, ezért a legszerencsésebb, ha a programot alkotó bináris 
	állomány nevét (argv [0] ) adjuk át paraméterként. 
	A függvény a második paraméterként kapott változatszámból csak az alsó 
	nyolc bitet használja fel. Fontos tudnunk, hogy a második paraméterként áta- 
	dott szám alsó nyolc bitje nem képviselhet 0 értéket. 
	A függvény visszatérési értéke a létrehozott azonosító, ha a mûvelet sikeres 
	volt, és -1, ha nem. A függvény által beállított errno változó értelmezése 
	ugyanúgy történik, mint a stat ( ) függvény esetében, az ftok() számára az 
	elsõ paraméterként átadott állománynévre vonatkozik. 
	
int shmget (key_t kulcs, int méret, int kapcs) ; 
	A függvény megosztott memóriát foglal, amely több folyamat által közösen 
	használható. A létrehozott megosztott memóriaterületet a folyamatok — így a 
	létrehozó folyamat is — csak akkor használhatja, ha csatlakozik hozzá. 
	A függvénynek átadott elsõ paraméter a kulcs, amelyet az ftok() függvény 
	segítségével hoztunk létre, a második paraméter a lefoglalandó memória mé- 
	rete, míg a harmadik a következõ kapcsolók által beállítható érték: 
	- IPC_CREAT Uj memóriaterület foglalására ad utasítást ez a kapcsoló. Ha nincs 
		bekapcsolva, a függvény már létezõ területhez kísérel meg kapcsolódni. 
	- IPC_EXCL Ha ez a kapcsoló is be van kapcsolva, a függvény hibát ad, ha már 
		le van foglalva memóriaterület a hivatkozott kulccsal. 
		A függvény által visszaadott érték a memória kezelésére használható szám 
		sikeres mûvelet esetén, illetve -1, ha hiba lépett fel. Ekkor a függvény beállítja 
		az errno értékét, ami a következõk egyike lehet: 
	- EINVAL A memóriaterület mérete nem megfelelõ vagy létezik már a megosz- 
		tott memóriaterület az adott kulccsal, de a kért méret nagyobb a mére- 
	- EEXIST Az IPC_CREAT és az IPC_EXCL be volt kapcsolva és a megosztott me- 
	- EIDRM A terület már létezik, de felszabadításra van kijelölve. 
	- ENOSPC A rendszer megosztott memóriaterületre vonatkozó korlátai kimerül- 
		tek, nem lehetséges újabb megosztott memóriaterületet lefoglalni. 
	- ENDENT Az IPC_CREAT kapcsoló nem volt bekapcsolva és az adott kulcshoz 
		nincs memóriaterület rendelve. 
		
	- EACCES Az adott folyamatot futtató felhasználónak nincs joga a megadott 
		megosztott memóriaterülethez férni. 
	- ENOMEM A mûvelet végrehajtásához nem áll rendelkezésre elegendõ memória. 
		Az 54. példa bemutatja az shmget ( ) függvény használatát és azt, hogy ho- 
		gyan kezelhetjük a megosztott memóriaterületeket a parancssorban indított 
		programok segítségével. 

void *shmat (int azonosító, const void *cím, int kapcs) ; 
	A függvény kapcsolódik az elsõ paraméterként megadott azonosítójú megosz- 
	tott memóriaterülethez, és megadja annak címét. 
	A függvény második paramétere megadja, hogy milyen memóriacímen szeret- 
	nénk elérni a megosztott memóriaterületet. A második paraméter értéke nem 
	tetszõleges, a következõképpen alakulhat: 
		• Ha a függvény második paramétere NULL érték, a rendszer választ egy 
		megfelelõ memóriaterületet, amelyen keresztül a folyamat elérheti a 
		megosztott memóriát. 
		• Ha a második paraméter nem NULL és a harmadik paraméterként átadott 
		kapcsolók közt szerepel az SHM_RND, a rendszer az átadott memóriacímet 
		kerekíti a szükséges értékre és az így kapható területen keresztül teszi 
		elérhetõvé a megosztott memóriát. 
		• Ha a második cím nem NULL és az SHM_RND nem szerepel a kapcsolók 
		közt, az átadott memóriacímnek az SHMLBA állandó többszörösére kell 
		esnie. 
	A függvénynek átadott kapcsolók a következõ értékekbõl állíthatók össze: 
	
	- SHM_RND A függvény a második paraméterként átadott memóriacímet szükség 
		esetén a megfelelõ értékre kerekíti. 
	- SHM_RDONLY A hozzáférés csak olvasható módon lesz engedélyezve. 
	
	A függvény visszatérési értéke a memóriaterület címe, amelyen keresztül a 
	megosztott memória tartalma elérhetõ, illetve -1 hiba esetén. Ekkor a függ- 
	vény beállítja az errno értékét, ami a következõk egyike lehet: 
	
	- EACCES A folyamatnak nincs joga az adott memóriaterülethez hozzáférni. 
	- EINVAL Ervénytelen azonosító vagy nem megfelelõ memóriacím. 
	- ENOMEM A mûvelet végrehajtásához nem áll rendelkezésre elegendõ memória. 


int shmdt (const void *cím) ; 
	A függvény a megosztott memóriaterületrõl való leválásra szolgál. A rendszer 
	akkor tudja felszabadítani a megosztott memóriaterületet, ha az összes csatla- 
	kozott folyamat lekapcsolódik róla a shmdt ( ) hívásával. Ha a folyamat kilép, 
	a leválás automatikusan megtörténik. 
	A függvény egyetlen paramétere az a cím, amelyet a megosztott memóriához 
	kapcsolódáskor adott vissza a shmat ( ) függvény. 
	A visszatérési érték 0, ha a lekapcsolódás sikeres volt, illetve -1 hiba esetén. 

int shmctl (int azonosító, int parancs, struct shmid_ds *jel 1) • 
	A függvény segítségével különféle mûveleteket végezhetünk a megosztott me- 
	móriaterületeken, lekérdezhetjük a tulajdonságait, átállíthatjuk azokat vagy 
	éppen törölhetjük a megosztott memóriaterületet az operációs rendszerbõl, 
	felszabadítva a területet, amelyet lefoglal. 
	A parancs elsõ paramétere az azonosító, segítségével a megosztott memória- 
	területet jelölhetjük ki, amelyre a második paraméterként átadott parancs vo- 
	natkozik. A harmadik paraméter a megosztott memória jellemzõit jelölõ mu- 
	tató, amely egy shmid_ds struktúrát jelöl a memóriában: 

	A shmid_ds struktúra 
	struct ipc_perm shm_perm 	A jogokat szabályozó struktúra. 
	int shm_segsz 				A méret bájtban. 
	time_t shm_atime 			A legutolsó kapcsolódás idõpontja. 
	time_t shm_dtime 			A legutolsó lekapcsolódás idõpontja. 
	time_t shm_ctime 			A legutolsó változtatás idõpontja. 
	unsigned short shm_cpid 	A létrehozó azonosítója. 
	unsigned short shm_lpid 	A legutolsó mûveletet kérõ azonosítója. 
	short shm_nattch 			A jelenlegi kapcsolatok száma. 
	
	A struktúrán belül található az ipc_perm struktúra, amelynek elemei a következõk: 
	A ipc_perm struktúra 
	key_t key	A létrehozáskor használt kulcs. 
	uid_t uid 	A tulajdonos azonosítója. 	
	gid_t gid	A tulajdonoscsoport azonosítója. 
	uid_t cuid	A létrehozó azonosítója. 
	gid_t cgid	A létrehozó csoport azonosítója. 
	unsigned short int mode  	Az alsó 9 bit a jogok leírása az állományoknál megszokott módon. 

	A második paraméterként a következõ állandók adhatók át: 
	- IPC_STAT A parancs a megosztott memória adatainak lekérdezésére vonat- 
		kozik. A függvény bemásolja a megosztott memória adatait a harmadik 
		paraméterként kapott címre. 
		A folyamatot futtató személynek a mûvelet végrehajtásához olvasási jog- 
		gal kell rendelkeznie a hivatkozott megosztott memóriára. 
	- IPC_SET A mûvelet a megosztott memória tulajdonságainak megváltoztatá- 
		sára vonatkozik. A függvény harmadik paramétere az új tulajdonságokra 
		mutat. 
		A folyamatot futtató személynek a megosztott memóriát létrehozó sze- 
		mélynek, a megosztott memória tulajdonosának vagy a rendszergazdá- 
		nak kell lennie, hogy a mûvelet sikeres lehessen. 
	- IPC_RMID A parancs a megosztott memória felszabadítására vonatkozik. A 
		függvény a parancs hatására törlésre jelöli a megosztott memóriát, de az 
		csak akkor szabadul fel, amikor az utolsó csatlakozást is felszabadítjuk. 
		A folyamatot futtató személynek a megosztott memória létrehozójának, 
		tulajdonosának vagy a rendszergazdának kell lennie. 
	- SHM_LOCK A megosztott memória csereterületre való kimásolásának tiltása. A 
		megosztott memóriaterület ezentúl nem kerülhet a virtuális memóriába. 
		A folyamatot futtató felhasználónak a rendszergazdának kell lennie. 
	- SHM_UNLOCK A memóriaterület virtuális memóriába való másolásának újra- 
		engedélyezése. A folyamatot futtató felhasználónak a rendszergazdának kell lennie. 
	
	A függvény visszatérési értéke 0, ha a mûvelet sikeres volt, és -1 hiba esetén. 
	Ekkor a függvény beállítja az errno értékét, ami a következõk egyike lehet: 
	- EACCES A memóriaterület adatait nem lehet lekérdezni, mert a folyamatot 
		futtató felhasználónak nincs olvasási joga a memóriaterületre. 
	- EFAULT A függvény harmadik paramétere nem elérhetõ, pedig a második pa- 
		raméterként átadott parancs szükségessé teszi a használatát. 
	- EINVAL A függvény elsõ vagy második paramétere érvénytelen értéket hordozott. 
	- EIDRM A megosztott memóriaterület már el van távolítva a rendszerbõl, fel 
		van szabadítva. 
	- EPERM A folyamatot futtató személynek nincs joga az adott mûvelet elvégzésére. 
	- EOVERFLOW Az IPC_STAT mûveletet nem lehet elvégezni, mert a felhasználói 
	azonosító vagy a csoportazonosító tárolására nem elegendõ a hely. 



54. példa. A következõ példaprogram egy kilobájtos megosztott memóriaterületet 
megosztott/shmget . c 
#include <stdio.h> 
#include <sys/types.h> 
#include <sys/ipc.h> 
int main(int argc, char *argv[]){
	key_ t  kulcs ; 
	int 	memoria; 
	
	kulcs = ftok(argv[0], 1);
	if(kulcs == -1){
		fprintf(stdern, "A kulcs létrehozása sikertelen”) ; 
		exit(1);
	}
	
	memoria = shmget (kulcs, 1024, IPC_CREAT | IPC_EXCL); 
	if(memoria == -1)
		fprintf( stderr, "A memória létrehozósa sikertelen. \n”); 
		ecit (1); 
	}
	exit (0) ; 
}
	A program a 9—13. sorban egy kulcsot hoz létre, amelyet a 15—19. sorban fel- 
	használ megosztott memória kérésére. A kéréskor átadott kapcsolók új megosztott 
	memóriaterület létrehozására szolgálnak; az IPC_ EXCL kapcsoló miatt az shmget ( ) 
	hibát ad vissza, ha az adott kulccsal már történt területfoglalás. 
	A program a megosztott memória létrehozása után a 20. sorban kilép, anélkül, 
	hogy bármilyen üzenetet írna a szabványos kimenetre. Ha tehát a memória létre- 
	hozása sikeres, a program kilép. Ha most újra futtatjuk a programot, a memória 
	létrehozása nem sikerül, hiszen az már létezik: 
		Bash$ ./shmget 
		Bash$ ./shmget 
		A memória létrehozósa sikertelen. 
		Bash$ 
	A rendszeren létezõ megosztott memóriaterületekról információkat az ipcs prog- 
	rammal kaphatunk, amelynek -m kapcsolója szolgál arra, hogy csak a megosztott 
	memóriáról kapjunk leírást: 
		Bash$ ipcs -m 
		-- Shared Memory Segments ---
		key 		shmid 	owner 	perms 	bytes 	nattch 	status 
		oc0102c011 	786432 	root	0 		1024 	0
		Bash$ 

	A program kimenetének elsõ oszlopában olvashatjuk a kulcsot, a másodikban a meg- 
	osztott memóriaterület azonosítóját, az ötödikben a memóriaterület méretét, míg a 
	hatodikban azt, hogy a megosztott memóriaterületet használó folyamatok hány csat- 
	lakozási Pontot építettek ki a memóriaterülethez. 
	A megosztott memóriaterületeket törölni az ipcrm paranccsal lehet. A parancs 
	után az shm kulcsszóval kell jelölnünk, hogy megosztott memóriát szeretnénk felsza- 
	badítani, utána pedig a memóriaterület azonosítójának kell következnie — amelyet a 
	ipcs által kiírt táblázat harmadik oszlopában találunk: 
		Bash$ ipcrm shm 786432 
		resource (s) deleted 
		Bash$ 

	Ha a megosztott memória törlése után újra futtatjuk a programot, annak újra 
	sikerül létrehoznia a megosztott memóriaterületet, de most már egy új azonosítót 
	kap a rendszertõl. A kulcs a régi marad, az azonosító azonban mindig új lesz. 

55. példa. A következõ példaprogram megosztott memóriát használ a gyermekfo- 
lyamatával való kapcsolattartásra. A program elõbb létrehoz egy megosztott memó- 
riaterületet, majd a fork() függvénnyel létrehozott gyermekfolyamatával közösen 
használja azt. 

megosztott/memoriahasznalat . c 
#include <stdio. > 
#include <sys/types. h> 
#include <sys/ipc. h> 
#include <sys/shm. h> 
#include <stTing. h> 
int memoria_letrehoz( const char *allomany ) { 
	key_ t kulcs; 
	int memoria; 
	kulcs = ftok(allomany, 1); 
	if(kulcs == -1) { 
		fprintf(stderr, "A kulcs létrehozása sikertelen”) ; 
		exit(l); 
	}
	memoria = shmget(kulcs, 1024, IPC_CREAT | IPC_EXCL); 
	if(memoria == -1) { 
		fprintf( stderr, "A memöria Létrehozasa siker•teten. \n"); 
		exit (1)
	}
	return (memoria) ; 
}

int main(int argc, char *argv[]){
	int memoria; 
	char *cim; 
	
	memoria=memoria_ tetrehoz( argv [O] ) ; 
	
	if(fork()!= 0) { 
		/* A szüLö fetadatai... */
		cim=shmat( memoria, NULL, 
		if((int)cim == -1){
			fprintf (stderr, "Szülö: nem Lehetett csatlakozni. \n"); 
			ecit(l); 
		}
		strcpy( cim, "A küldött üzenet szövege...");
		wait (NULL); 
		printf ( "SzüLö: a fogadott üzenet: %s \n", cim); 
		shmdt (cim) ; 
		
		if(shmctl( memoria, IPC_RMID, NULL) != 0) {
			fprintf( stderr, "Szülö: nem behetett  törölni. \n" );
			exit(l); 
		} / *if* / 
		ecit (O) ; 
	}
	else {
		/* A gyermek fetadatai */
		cim = shmat (memoria , NULL, 0);
		if(cim == NULL){
			fprintf( stderr, "Gyermek: nem Lehetett csatlakozni. \n"); 
			exit(l); 
		}
		
		printf( "Cyermek: a fogadott üzenet: 
		strcpy( cim, "A visszaküldött üzenet", cim ) ; 
		
		shmdt (cim) ; 
		exit (0) ; 
	}
}

	A program helyes futás esetén csak két üzenetet ír a képernyõre, az elsõ üzenet jelzi, 
	hogy a gyermek felhasználta a szülõ által elhelyezett memóriatartalmat, a második 
	pedig, hogy a szülõ megkapta a válaszként adott szöveget a megosztott memóriában. 
		Bash$ ./memoriahasznalat 
		Gyermek: a fogadott üzenet: A küldött üzenet szövege... 
		Szülõ: a fogadott üzenet: A visszaküldött üzenet szövege 
		Bash$ 

A program 7—24. sorában található memoria_ letrehoz ( ) nevú függvény megosz- 
tott memóriát hoz létre és visszaadja az annak kezelésére szolgáló egész számot. A 
26. sorban kezdõdõ main ( ) függvény a 30. sorban hívja a függvényt és a memória 
kezelésére használható egész számot elhelyezi a memoria nevú változóban. 
A program a 30. sorban található fork() hívással új folyamatot hoz létre ön- 
maga lemásolásával. A függvényhívásnak köszönhetõen született két folyamat örökli 
a memoria változó értékét, és mindkét folyamat hozzáférhet az osztott memóriához. 
A szülófolyamat a 33. sortól az 50. sorig tartó utasításokat hajtja végre. Ez a prog- 
ramrészlet elõször az osztott memóriához csatlakozik a 36. sorban található függ- 
vényhívással. A szülõ ezután a 41. sorban bemásol egy szöveget a megosztott memó- 
riába az itt kapott cím felhasználásával. A szülõ ezzel átadta a szöveget a megosztott 
memórián keresztül, és a 42. sorban várakozik a gyermekfolyamat befejezõdésére. A 
szülõ csak akkor folytatja a 43. sorban a futást, ha a gyermek befejezódött. Ekkor 
a 43. sorban kiírja a közös memóriaterület tartalmát, amely most már a gyermek 
válaszát tartalmazza. A szülõ ezután a 45. sorban lekapcsolódik a közös memória- 
területrõl és a 46. sorban kijelöli a memóriaterületet törlésre. A szülõ az 50. sorban 
található függvényhívással lép ki, ha a futás során nem lépett fel hiba. 
A gyermek által végrehajtott utasítások az 52. sorban kezdõdnek. A gyermek elõ- 
ször kapcsolódik az SS. sorban található függvényhívás segítségével a megosztott 
memóriaterülethez. A memóriaterület kezelését ezután a cim változóban tárolt cím 
alapján végzi a gyermek, ahogyan a szülõ is. A gyermek ezután felfüggeszti futását 
néhány másodpercre, hogy idót adjon a szülõnek az üzenet elhelyezésére. A várakozás 
után a gyermek kiírja a szabványos kimenetre a szülõ által a megosztott memóriába 
helyezett szöveget, majd egy másik szöveget helyez oda válaszul. Ezek után a gyer- 
mek lekapcsolódik a megosztott memóriáról a 63. sorban és kilép a 64. sorban. 