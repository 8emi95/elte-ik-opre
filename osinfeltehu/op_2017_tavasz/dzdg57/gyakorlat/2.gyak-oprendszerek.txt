klettner.web.elte.hu

char str[20]	19 elemû tömb
char str2[] = "Hajra Vasas!"	12 karakter, de 0 miatt 13 elemû tömb... (ezért veszélyes ez a deklaráció)

ilyet NEM fogad el:
str = "Hajra Ujpest!"

Hogyan lehetne mégis értéket adni neki?
include-olni kell a string.h-t

strcpy({cél}, {forrás})
pl.
strcpy(str, str2)
strcpy(str, "Hajra Fradi!")


* : értéke operátor
& : címe operátor


char* ptr_str, p_str2;   // elsõ mutató, második már karakter típusú változó lesz!!!
char *ptr_str, *p_str2;	 // mindkettõ mutató!

// mutatónak így tudunk értéket adni:
ptr_str = &str[0]	// ekkor mindakettõ ugyanarra a memóriacímre fog mutatni!
ptr_str = str		// ez ugyanaz mint az elõbbi... egy kis egyszerûsítés


ptr_str
&ptr_str[0]	// ez a kettõ megint ekvivalens... 1.karakterre mutatnak ... mondjuk kiiratásnál innentõl iratunk ki

//hogyan lehet a hetedik karakterre mutatni? így:
ptr_str+6
&ptr_str[6]

ptr_str[0]	
*ptr_str	// 1.karakterre hivatkozás (itt van jelentõsége, hogy pointer típusként deklaráltuk a pointert!)

ptr_str[11]	
*(ptr_str+11)	// 11. indexen (12.karakter) lévõ érték...




DINAMIKUS memóriafoglalás:
szükség van az stdlib.h-ra
itt találunk egy olyat, hogy malloc

malloc({byte})	// eredményül egy memóriacímet(mutatót) ad vissza, ahol elkezdõdik az az összefüggõ memóriaterület, amit lefoglalt
// ha nem sikerült, akkor 0-át ad vissza

char *s;
s = malloc(20);
(hasonló hatás, mint s[20], DE utóbbi blokk végén feloldódik, malloc-nál nekünk kell feloldani a memóriát)

free({mutató})	// felszabadítja a malloc által lefoglalt memóriaterületet
pl:
free(s)

// szakszerûbb használat:
s = (char*)malloc(20*sizeof(char));	// elején jelzem, hogy egy karaktertípusú mutató...

mutató = (elemtípus*)realloc(mutató, {memóriaméret})	// a bal oldalon lévõ mutató az elõzõ helyfoglalás
// ha nullát ad vissza, akkor bennemarad az elõzõ érték
https://www.tutorialspoint.com/c_standard_library/c_function_realloc.htm


String.h-ban további függvények
strlen({mutató})	// aktuálisan milyen hosszú
strcmp(str1, str2)	// valójában elsõ karakterkódeltérést adja vissza
strcat(cél, forrás)	// hozzáfûzés	




// Készítsünk egy strlen() szerû függvényt! legyen int length()

Házi! equal függvényt!
// akkor ad nem nullát ha egyenlõek és nullát ha nem egyenlõek