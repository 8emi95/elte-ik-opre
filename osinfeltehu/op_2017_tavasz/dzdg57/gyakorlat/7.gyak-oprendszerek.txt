2017.05.08.

Ha szignállal küldünk akkor lehet egészt és mutatót is küldeni, DE
Ha mutatót adunk át, akkor bár átmegy a mutató, de a másik folyamatban az teljesen máshova mutat

Közös kódban kell deklarálni és értéket adni a struktúrának, aminek a mutatóját átadom


Ma csövekrõl lesz szó... ez kell beadandóhoz
Jövõ héten üzenetsor  (zh-ban valószínû, hogy üzenetsorral kell megoldani a feladatot, nem csõvezetékkel
figyeljünk majd a zh szövegére!) 

A szignáloknál sok problémába ütközünk... mit tehetünk...
Csõ (pipe) használat
FIFO fájl jön létre, nekünk csak az adatok bevitelével és kiolvasásával kell törõdnünk
A csõ mindig egy irányú... két vége van, egyik vége csak írásra, másik csak olvasásra használható

névtelen csõ:
pipe(int pipefd[2])	egy kételmû tömböt kap paraméterül
létrehoz egy csövet és a fájlazonosítókat(írásra és olvasásra valót...tehát a csõ két végének azonosítóját)
elhelyezi a pipefd tömbbe... [0] -ba olvasásit [1]-be írásit
a csõ végeit külön-külön kell lezárni, méghozzá szálonként, folyamatonként
akkor tekinthetõ egy vég lezártnak ha az összes olyan folyamat, ami használta lezárta
(tehát ha van olyan szálam, amiben nem zártam le a csõ végét, akkor az olvasó folyamat nem
fogja megkapni!)
[0]-s vég csak akkor ad eof-ot ha beolvasásra került minden adat belõle és lezártuk

pipe.c mintaprogram
az egyik folyamatunk ténylegesen át tudott információt adni a másik folyamatnak!

egy másik példaprogram...
miért duplázódik meg a vége?

ha szülõnél nem zárom le az írási véget(tehát ha  (close(pipefd[1])-et kikommenteljük,
akkor sohza nnem fog megérkezni a 11. adat és a gyermek 10után vár...)
ha a gyerekben nem zárom le? akkor ugyanaz a helyzet
(ne felejtsük tehát el, hogy abban a folyamatban is zárjuk le, ahol nem használjuk)


mégegy mintaprogram...
3 szállal

for ciklus elõtt zárom le az írásit...



minden folyamatnak külön csövet hozhatunk létre kiolvasásra...
(összes többi folyamatnál az olvasási végét lezárjuk annak a csõnek, így csak az tud olvasni,
amelyiknek ténylegesen szántuk)


Következõ csõtípus: nevesített csõ
(abban különbözik a névtelen csõtõl, hogy mi adjuk meg neki, hogy mi az a fájl, amit használ.
bármilyen folyamattal (akinek joga van írni, olvasni a fájlt) hozzáférhetünk...

mkfifo(fájlnév, engedélyek)	ez hozza létre a megadott fájlnéven a csõfájlt az általunk
megadott hozzáférési engedélyekkel.... egy fajlazonositot ad vissza
értéke 0, ha sikerült létrehozni, -1, ha nem sikerült

unlink(fájlnév)		így törölhetjük a fájlt

(fájlkezelésnél használt megszokott read, write...)

ilyen csõnél mindkét véget meg kell nyitni



nevcso.c mintaprogram!


4c1.c és 4c2.c mintaprogram (fotó)



nekünk mégiscsak a hatékonyság növelés lenne a cél...
include-olni kell a <poll.h>-t

pollfd: fd : fileazonosító
	events: figyelt esemény(short típus)
	revents: bekövetkezett esemény(short típus)

ezek az események lehetnek: POLLIN és POLLOUT

poll(figyelendõk tömbje, figyelendõk száma, idõtúllépés)
figyelendõk tömbje pollfd struktúrákból áll
figyelendõk száma azt határozza meg, hogy a figyelendõk tömbjébõl hány érvényes elem van
(ez nem az index...)
idõtúllépés ms-ban


poll_cso.c mintafájlt otthon nézzük meg




ppoll(figyelendõk tömbje, figyelendõk száma, idõtúllépés, szignálmaszk)
idõtúllépés itt timespec-ben (nem ms-ban)


ppoll.cso.c -t otthon...
ha 33-34-et futtatjuk a 31-32 helyett, akkor is tovább megy
ha 31-34-ig kikommenteljük, akkor idõtúllépés viszi tovább



<sys/select.h>
fd_set	fájlleíró készlet típus
FD_ZERO(készlet)	készlet kiürítése
FD_SET(fájlazonosító, készlet)	hozzáadjaa a megadott fájlazonosítót a készlethez
FD_CLEAR(fájlazonosító, készlet) eltávolítja a megadott fájlazonosítót a készletbõl
FD_ISSET(fájlazonosító, készlet) akkor ad nullát ha nem tartalmazza fájlazonosítót a készlet
ha tartalmazza, akkor nem nullát ad...
select(ndfs, readfs, writefs, exceptfs, idõtúllépés)
readfs, writefs, exceptfs	fájlleírók
idõtúllépés timeval típusú... (0-val folyamatosan blokkol (pollnál azt jelezte, hogy csak ránéz és megy tovább) )
ndfs-nek a legnagyob fájlleíró száma+1 -et kell megadni
pl readfs: 5, writefs: 3, exceptfs: 7, akkor adjunk meg 8-at ndfs-nek

ha nagyobb mint nullával tér vissza, akkor egy vagy több fájlban megtörténik az az esemény,
amit figyelünk
figyeli a fájlleíró készletében megadott fájlokat... felfüggeszti a ...

sel_cso.c



<sys/ipc.h>
ftok(path, project id)	ipc kulcsot generál számunkra...
path-nak olyan fájlra kell mutatni, amihez jogosultságunk van hozzáférni
gyakran szoktuk argv[0]-t (tehát a saját fájlt) használni...
vagy pl "/tmp" -t
a project id az egy saját szám...
key_t típusú érték a visszatérési érték (valójában egy egész szám)...egy 8 bites kulcs
(ha negatív, akkor hiba történt)

msgget(kulcs, jogosultságok)	ez hozza létre magát az üzenetsort...
kulcs helyére vagy egy ftok-kal generált kulcsot teszünk, vagy 
IPC_PRIVATE (ennél viszont külsõ program nem látja)
ha ftok-kal generált kulcsot használom, akkor tetszõleges helyrõl induló folyamat tud
kommunikálni(feltéve ha van hozzáférési joga a fájlhoz)

IPC_CREAT...

msgsnd(üzenetsor azonosító, &üzenetstruktúra, méret, flag)
elküldi a megadott üzenetsor azonosítójú üzenetsorba az üzenetet
a flag vagy nulla, vagy IPC_NOWAIT...
ha nulla és nem lehet valamiért írni az üzenetsorba, akkor blokkolni fogja a folyamatot...
ha IPC_NOWAIT, akkor nem blokkolódik, továbblép...

long típusú érték
üzenet ... hivatalosan karaktertömb...

ha sikerül elküldeni 0-át ad vissza..., ha nem -1-et... (ha minden igaz...)


msgrcv(üzenetsor azonosító, &üzenetstruktúra, méret, fogadó puffer mérete, üzenet kategória, flag)
ha üzenetkategória 0, akkor a soron következõ üzenetet olvassa ki
ha nem nulla, akkor azt a következõt, ami a kategóriánál meg van adva...
ha nincs a sorban a kategóriának megfelelõ üzenet, akkor itt is a flag vagy 0, vagy IPC_NOWAIT


msgctl(üzenet azonosító, IPC_RMID, NULL)
így paraméterezve fogja törölni az üzenetsort...
0-át ad ha sikerül, -1-et ha nem sikerül törölni

uzenet.c mintafájlt otthon