Maszkolás
Azok a szignálok, amik blokkolva vannak..ami benne van a maszkba, azt fogjuk blokkolni

<signal.h> -ból
sigset_t	signálok halmaza

pl.	sigset_t sigset

sigemptyset(&sigset)	inicializálja...
sigfullset(&sigset)	ha ezzel maszkolunk, akkor semmiféle signál nem jut be... ritkán kell
sigaddset(&sigset, {szignál})	hozzáadja a szignált
sigdelset(&sigset, {szignál})	eltávolítja a szignált a készletbõl
sigprocmask(mûvelet, &sigset, &oldset)	beállítja a szignálok blokkolását
	mûveletek:
	SIG_BLOCK	
	SIG_UNBLOCK
	SIG_SETMASK	pontosan az legyen maszkolva, amit mi átadunk

	sigset az a szignálkészlet, amit beállítunk most maszknak
	az oldset, ami az elõzõ maszkolás állapotát elmenti... ha nem akarjuk használni, akkor NULL
	
	visszatérési érték 0, ha sikeres, -1, ha nem volt sikeres


NEM MASZKOLHATÓ SZIGNÁLOK: SIGKILL és a SIGSTOP


sigprocmask.c-t megnéztük...
bár a sigtermet küldi el elõbb a gyerek, de mivel blokkolva volt, így csak a blokkolás feloldása után kapja meg



a signal függvénnye tudtunk eddig handlert rendelni szignálhoz
a sigaction függvénnyel tudunk több információt kapni a szignálról... mi váltotta ki...
(a signal és a sigaction függvényt egy programon belül inkább ne használjuk!)

<signal.h>
struct sigaction
	sa_handler: 	handler
			SIG_DFL
			SIG_IGN
	sa_mask:	sigset_t	a további végrehajtási szignálokat ad hozzá...addig amig fut a handler
	sa_flags:	0: alapviselkedés
			SA_SIGINFO:	ha nincs beállítva: 	void handler(int signo)
					ha be van állítva:	void handler(int signo, siginfo_t * info, void * context)

sigaction(signum, &act, &oldact)	// ne zavarjon, hogy ugyanaz az azonosítója s struktúrának, mint a függvénynek... (struktúra elé úgyis be kell tenni a struct megkülönböztetõ jelzést)

sigsuspend(&mask)		// átmenetileg lecseréli a maszkját erre a maszkra


sigaction.c
//beleírtam megjegyzéseket!!!


/////////////////////////
REALTIME szignálok:

SIGRTMIN és SIGRTMAX közé esõ szignálok a realtime szignálok
ha többet akarok használni, pl 2-t akkor:
SIGRTMIN
SIGRTMIN+1

ezeknek nincs elõre definiált jelentésük... magasabb a prioritásuak a standard szignálokénál
az azonos realtime szignálok kiszolgálása viszont beérkezési idõtõl függ...(pl két SIGRTMIN)
a SIGRTMIN viszont magasabb prioritású, mint a SIGRTMIN+1

fordításnál -lrt kapcsolót is használjuk (elhagyása nem mindig okoz fordítási hibát, de gyanakodjunk)
pl.:	gcc 5.c -lrt



sigaction_multiple.c



<signal.h>
raise(signal)
<unistd.h>
alarm(másodperc)	mikor letelik a másodpercben megadott érték, akkor küld egy SIGALARM-ot
			ha ezen idõ lejárta elõtt adok ki egy alarm(0)-t, akkor leállítom az idõzítõt

<sys/time.h>
struct itimerval
	it_interval	ha ide nem nulla van, akkor annyi idõ után újra indítja az idõzítõt
	it_value	az elsõ idõzítésig mennyi idõ teljen el
struct timeval
	tv_sec
	tv_usec

settimer(idõzítõ, &újtimer, &régi timer)
	ITIMER_REAL 	-> SIGALARM
	ITIMER_VIRTUAL	-> SIGVTALARM
	ITIMER_PROOF	-> SIGPROOF

gettimer(idõzítõ, &timer)



!!!! setitemer.c-t nézzük meg
ha nem értjük küldjünk el e-mailt és kapunk szöveges választ...
ha értjük tudunk válaszolni az alábbi kérdésekre:
- hogyan állítja le a handlersettimer a programot?
- mit csinál a handlersettimer 19. és 20. sora?
- miért írja ki ezt?:  ...0 seconds... 




union a {
	típus1 adattag 1;	// pl int i;
	típus2 adattag 2;	// pl char c;
}

elérés:
a.i
a.c



info->si_code	// ki küldte... pl SI_TIMER, SI_USER...
info->si_valu	// egy a szignállal küldött unio típusú információ
		// ez lehet:	int : info->si_value.sival_int	 // így hivatkozunk rá
			   	ptr : info->si_value.sival_ptr	 



<signal.h>
sigqueu(PID, signal, value) // megadom kinek küldöm, magát a szignált, és egy értéket, ami pointer vagy egész szám...



<time.h>
timer_create(clock id, &signal event, &timer id)
	clock id:	CLOCK_REALTIME
			...
	sigevent
		sigev_notify:	SIGEV_NONE
				SIGEV_SIGNAL
	sigev_signo	// ez maga szignál amit küldünk
	
	sigev_value
	
	timer id: timer_t


itimerspec

timer_settime(timer id, flags, &új timer, &régi timer)		// beállítja és elindítja ezt a timer id azonosítójú idõzítõt...

timer_gettime(timer id, &akt. érték)

timer delete(timer id)



sigaction_value.c-t nézzük meg!
vannak olyan struktúráink, hogy zoli, who és adam
- a 100. sorban ha zoli helyett adamot kuldjuk akkor mi okozza problémát ? (lehet nem jól írtam le)
- ha 100. sorba beszúrjúk : strcpy(zoli.name, "Fradi")
  a 101. sorban pedig:	    zoli->küldjük
  akkor mi íródik ki?
