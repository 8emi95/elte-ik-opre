#include <sys/ipc.h> 
#include <sys/msg.h> 
#include <sys/types.h> 
#include <stdio.h> 
#include <stdlib.h> 
#include <string.h> 
#include <unistd.h> 
#include <wait.h> 


struct messgequeue { 
  long mtype;
      char mtext [ 1024 ]; 
      
      
};
       

int send( int mqueue ) 
{ 
  const struct messgequeue m = { 3, "55 , 95 , 67" }; 
   int status; 
               
    status = msgsnd( mqueue, &m, strlen ( m.mtext ) + 1 , 0 ); 


      if ( status < 0 ) 
        perror("msgsnd error"); 
            return 0; 
}

int receive( int mqueue ) 
{ 
struct messgequeue  m; 
int status; 

   
status = msgrcv(mqueue, &m, 1024, 3, 0 ); 
        
if ( status < 0 ) 
perror("msgsnd error"); 
else
 
printf("\n The coordinates are: %s \n", m.mtext);
return 0; 
} 

//
void handler(int signumber){
 printf("Signal with number %i has arrived\n",signumber);
  }
//
int main (int mqueue, char* argv[]) { 
  pid_t child; 
  int messgequeue , status; 
  key_t key;
  pid_t pid;   
  //
  int pipefd1[2];
  signal(SIGTERM,handler); 
  srand(time(NULL)); 
  if (pipe(pipefd1) == -1)
  {
  perror("Opening error!");
  exit(EXIT_FAILURE);
  }
  
  key = ftok("\temp",1);
  printf ("THE KEY is: %d\n",key );
  messgequeue = msgget( key, 0600 | IPC_CREAT );
  if ( messgequeue < 0 ) {
  perror("msgget");
  return 1;
  }
  
  if (pid == 0) 
  {printf("Waits 3 seconds, then send a SIGTERM %i signal\n",SIGTERM);
  sleep(3);
  kill(getppid(),SIGTERM);
int counter=0;
  
close(pipefd2[0]); 
sleep(3);
struct messg m;
do{

int p;
p=rand()%10+1;
write(pipefd2[1], &p, sizeof(int)); 
 printf("Child wrote the message to the pipe!\n");
   fflush(NULL);         
    int status;
    int length;
       length = sizeof(struct messgqueue ) - sizeof(long);
   status = msgrcv(messgequeue, &m,length, 5, 0 );
   if ( status < 0 )
  perror("msgrcv");
       else{
  printf( "The child received message: %ld, the text is:  %s\n", m.mtype, m.mtext );
        }
  counter++;
          }  
  
  
  //                  
  
                               
  key = ftok(argv[0],1); 
  printf ("The key: %d\n",key);
    messgequeue  = msgget( key, 0600 | IPC_CREAT ); 
     if ( messgequeue < 0 ) { 
     perror("msgget error"); 
         return 1; 
}    


child = fork(); 
  if ( child > 0 ) { 
   send( messgequeue );   
    wait( NULL );
    
    status = msgctl(messgequeue, IPC_RMID, NULL ); 
         if ( status < 0 )
  perror("msgctl error"); 
    return 0; 
      } else if ( child == 0 ) { 
        return receive( messgequeue ); 
     
      } else { 
      perror("fork error"); 
      return 1;                                                   
    }
                                                                          
   return 0; 
} 