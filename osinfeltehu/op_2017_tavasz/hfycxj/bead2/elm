child = fork();			ezzel ágazik ketté
	child < 0 		exit(), mert a fork nem sikerült
	if child > 0		a szülõ, a fõ folyamat
	else child = 0		ez a gyerek, a mellékszál


waitpid( pid_t fork nevét kapja	, &status, 0)		várakoztatás, csak az elsõ paramétert kell változtatni

getpid()		egyedi azonosító, amelyik folyamatban van -> ...pp... a szülõé, stb;

system(stringet kap)		amit kap pareméterül, az olyan mintha a parancssorba írnám, azaz teljesíti azt az utasítás

struct flock lock_data; 		ezennek vannak kapcsolói!!
lock_data-l.whence =
	.SEEK_SET				start file, azaz elõrõl olvassa a fájlt
	.SEEK_END				végérõl olvassa
	.SEEK_CUR				melyik pont zárolom a fájlt 		
lock_data.l_pid = getpid()			melyik azonosító blokkolja az olvasást
lock_data.l_type = 				mit blkkoljon olvasást, vagy írást.
	.un_lock				blokkolás befejezése
fcntl(melyik fájlt, MARAD, &lock_data)		ez végzi el a lokkolást

pipe( int pipefd[2])				[0] -> olvasás		||    [1] -> írás
ussleep / sleep					a megadott másodpercig altatja
close ( pipefd[])				amit bezárunk
read( honnan, hova, mennyi hosszúságut)		mindig pipefd[0]-ból olvasunk!!	addig vár, amíg nem write-ol bele valaki
fflush(NULL)					mindent kitisztít, ami közben jött
unlink(string)					bezárja, de addig nem, amígy olvasok vagy írok, maybe az osztott memóriában


signal( Sigterm/Sigusr1/sigusr2 , void handlert kapja)		egyet tud egyszerre tárolni, több esetén külön megírni
kill( kinek a getpid() alapján , mit ~ amit elötte signallal létrehoztunk)	ez küldi csak el a signalt!!

struct sigaction sigact				több signal léterhozása másképp
	sigact.sa_handler = void handler		majd
sigaction( SIGTERM / stb , &sigact, NULL)		így hozza létre

sigset_t sigset... + alatta 4 sor		3. sor végén a SIGTERM <- amit odaadunk, arra nem fog reagálni, ha valaki meghívja rá a kill-el


OSZTOTT MEMÓRIA		- úgy lehet beleírni, hogy közben nem kell kiolvasni 
s = shmat ( mit ,  MARAD, MARAD)
shmget( kulcs, MARAD)			osztott mem. id-ját hozza létre.
shmdt(s ami az elsõ sorban volt változó)		elengedi a megadott osztot mem.-t
shmcte( osztott mem. id  , MARAD)			törli az osztott memót


UZENET.C
 uzenet, kuld, fogad függvények minidig megmaradnak, csak a printf() stringjét módosítani

ftock( argv[0], 1)		egyedi kulcsot hoz létre, MAIN-be BELE KELL ÍRNI A PARAMÉTEREKET
msgget				létrehozza az üzenetsort
msgctl				státuszt kér le, sikerült-e elküldeni az üzenett, stb, ha 0-val tér vissza akkor OK
	
								